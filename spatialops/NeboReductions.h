/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_REDUCTIONS_H
   #define NEBO_REDUCTIONS_H

   #define field_max nebo_max

   #define field_max_interior nebo_max_interior

   #define field_min nebo_min

   #define field_min_interior nebo_min_interior

   #define field_sum nebo_sum

   #define field_sum_interior nebo_sum_interior

   #define field_norm nebo_norm

   #define field_norm_interior nebo_norm_interior

   namespace SpatialOps {
      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_fold(bool useGhost,
                                                       typename FieldType::
                                                       value_type (*proc)(typename
                                                                          FieldType::
                                                                          value_type,
                                                                          typename
                                                                          FieldType::
                                                                          value_type),
                                                       typename FieldType::
                                                       value_type initialValue,
                                                       NeboExpression<ExprType,
                                                                      FieldType>
                                                       const & fexpr) {
          typename FieldType::value_type typedef value_type;

          ExprType initial = fexpr.expr();

          structured::GhostData ghosts = (useGhost ? initial.possible_ghosts() :
                                          initial.minimum_ghosts());

          const int xLow = - ghosts.get_minus(0);

          const int xHigh = initial.extent(0) + ghosts.get_plus(0);

          const int yLow = - ghosts.get_minus(1);

          const int yHigh = initial.extent(1) + ghosts.get_plus(1);

          const int zLow = - ghosts.get_minus(2);

          const int zHigh = initial.extent(2) + ghosts.get_plus(2);

          value_type result = initialValue;

          typename ExprType::SeqWalkType expr = initial.init();

          for(int z = zLow; z < zHigh; z++) {
             for(int y = yLow; y < yHigh; y++) {
                for(int x = xLow; x < xHigh; x++) {
                   result = proc(result, expr.eval(x, y, z));
                };
             };
          };

          return result;
       };

      template<typename AtomicType>
       inline AtomicType nebo_scalar_max(AtomicType a, AtomicType b) {
          return ((a < b) ? b : a);
       };

      template<typename AtomicType>
       inline AtomicType nebo_scalar_min(AtomicType a, AtomicType b) {
          return ((a > b) ? b : a);
       };

      template<typename AtomicType>
       inline AtomicType nebo_scalar_sum(AtomicType a, AtomicType b) {
          return a + b;
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_max(NeboExpression<ExprType,
                                                                     FieldType>
                                                      const & fexpr) {
          return nebo_fold(true, nebo_scalar_max, -1.0 / 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_max(FieldType const & field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_max(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_max_interior(NeboExpression<ExprType,
                                                                              FieldType>
                                                               const & fexpr) {
          return nebo_fold(false, nebo_scalar_max, -1.0 / 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_max_interior(FieldType const &
                                                               field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_max_interior(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_min(NeboExpression<ExprType,
                                                                     FieldType>
                                                      const & fexpr) {
          return nebo_fold(true, nebo_scalar_min, 1.0 / 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_min(FieldType const & field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_min(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_min_interior(NeboExpression<ExprType,
                                                                              FieldType>
                                                               const & fexpr) {
          return nebo_fold(false, nebo_scalar_min, 1.0 / 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_min_interior(FieldType const &
                                                               field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_min_interior(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_sum(NeboExpression<ExprType,
                                                                     FieldType>
                                                      const & fexpr) {
          return nebo_fold(true, nebo_scalar_sum, 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_sum(FieldType const & field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_sum(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_sum_interior(NeboExpression<ExprType,
                                                                              FieldType>
                                                               const & fexpr) {
          return nebo_fold(false, nebo_scalar_sum, 0.0, fexpr);
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_sum_interior(FieldType const &
                                                               field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_sum_interior(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_norm(NeboExpression<ExprType,
                                                                      FieldType>
                                                       const & fexpr) {
          return std::sqrt(nebo_sum(pow(fexpr, 2)));
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_norm(FieldType const & field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_norm(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };

      template<typename ExprType, typename FieldType>
       inline typename FieldType::value_type nebo_norm_interior(NeboExpression<ExprType,
                                                                               FieldType>
                                                                const & fexpr) {
          return std::sqrt(nebo_sum_interior(pow(fexpr, 2)));
       };

      template<typename FieldType>
       inline typename FieldType::value_type nebo_norm_interior(FieldType const
                                                                & field) {
          NeboConstField<Initial, FieldType> typedef ExprType;

          return nebo_norm_interior(NeboExpression<ExprType, FieldType>(ExprType(field)));
       };
   } /* SpatialOps */

#endif
/* NEBO_REDUCTIONS_H */
