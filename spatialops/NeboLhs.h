/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_LHS_H
   #define NEBO_LHS_H

   namespace SpatialOps {
      #ifdef __CUDACC__
         template<typename LhsType, typename RhsType>
          __global__ void gpu_assign_kernel(LhsType lhs,
                                            RhsType rhs,
                                            int const xLow,
                                            int const xHigh,
                                            int const yLow,
                                            int const yHigh,
                                            int const zLow,
                                            int const zHigh) {
             lhs.assign(rhs, xLow, xHigh, yLow, yHigh, zLow, zHigh);
          }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename FieldType>
       struct NeboField;
      template<typename FieldType>
       struct NeboField<Initial, FieldType> {
         public:
          FieldType typedef field_type;

          NeboField<SeqWalk, FieldType> typedef SeqWalkType;

          #ifdef FIELD_EXPRESSION_THREADS
             NeboField<Resize, FieldType> typedef ResizeType;
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             NeboField<GPUWalk, FieldType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboField(FieldType f)
          : field_(f)
          {}

          template<typename RhsType>
           inline void assign(bool const useGhost, RhsType rhs) {
              /* field_.reset_valid_ghosts(calculate_actual_ghost(useGhost,
                                                                  field_.get_ghost_data(),
                                                                  field_.boundary_info(),
                                                                  rhs.possible_ghosts()))
               */;

              structured::GhostData extents = calculate_limits(useGhost,
                                                               field_.window_with_ghost(),
                                                               field_.get_valid_ghost_data(),
                                                               field_.get_ghost_data(),
                                                               field_.boundary_info(),
                                                               rhs.possible_ghosts());

              const int xLow = - extents.get_minus(0);

              const int xHigh = extents.get_plus(0);

              const int yLow = - extents.get_minus(1);

              const int yHigh = extents.get_plus(1);

              const int zLow = - extents.get_minus(2);

              const int zHigh = extents.get_plus(2);

              #ifdef __CUDACC__
                 #ifdef NEBO_GPU_TEST
                    gpu_test_assign<RhsType>(rhs,
                                             xLow,
                                             xHigh,
                                             yLow,
                                             yHigh,
                                             zLow,
                                             zHigh)
                 #else
                    if(gpu_ready()) {
                       if(rhs.gpu_ready(gpu_device_index())) {
                          gpu_assign<RhsType>(rhs,
                                              xLow,
                                              xHigh,
                                              yLow,
                                              yHigh,
                                              zLow,
                                              zHigh);
                       }
                       else {
                          std::ostringstream msg;
                          msg << "Nebo error in " << "Nebo Assignment" << ":\n";
                          msg << "Left-hand side of assignment allocated on ";
                          msg << "GPU but right-hand side is not ";
                          msg << "(completely) accessible on the same GPU";
                          msg << "\n";
                          msg << "\t - " << __FILE__ << " : " << __LINE__;
                          throw(std::runtime_error(msg.str()));;
                       };
                    }
                    else {
                       if(cpu_ready()) {
                          if(rhs.cpu_ready()) {
                             cpu_assign<RhsType>(rhs,
                                                 xLow,
                                                 xHigh,
                                                 yLow,
                                                 yHigh,
                                                 zLow,
                                                 zHigh);
                          }
                          else {
                             std::ostringstream msg;
                             msg << "Nebo error in " << "Nebo Assignment" <<
                             ":\n";
                             msg << "Left-hand side of assignment allocated on ";
                             msg << "CPU but right-hand side is not ";
                             msg << "(completely) accessible on the same CPU";
                             msg << "\n";
                             msg << "\t - " << __FILE__ << " : " << __LINE__;
                             throw(std::runtime_error(msg.str()));;
                          };
                       }
                       else {
                          std::ostringstream msg;
                          msg << "Nebo error in " << "Nebo Assignment" << ":\n";
                          msg << "Left-hand side of assignment allocated on ";
                          msg << "unknown device - not on CPU or GPU";
                          msg << "\n";
                          msg << "\t - " << __FILE__ << " : " << __LINE__;
                          throw(std::runtime_error(msg.str()));;
                       };
                    }
                 #endif
                 /* NEBO_GPU_TEST */
              #else
                 cpu_assign<RhsType>(rhs, xLow, xHigh, yLow, yHigh, zLow, zHigh)
              #endif
              /* __CUDACC__ */;
           }

         private:
          template<typename RhsType>
           inline void cpu_assign(RhsType rhs,
                                  int const xLow,
                                  int const xHigh,
                                  int const yLow,
                                  int const yHigh,
                                  int const zLow,
                                  int const zHigh) {
              #ifdef FIELD_EXPRESSION_THREADS
                 if(is_thread_parallel()) {
                    thread_parallel_assign<RhsType>(rhs,
                                                    xLow,
                                                    xHigh,
                                                    yLow,
                                                    yHigh,
                                                    zLow,
                                                    zHigh);
                 }
                 else {
                    sequential_assign<RhsType>(rhs,
                                               xLow,
                                               xHigh,
                                               yLow,
                                               yHigh,
                                               zLow,
                                               zHigh);
                 }
              #else
                 sequential_assign<RhsType>(rhs,
                                            xLow,
                                            xHigh,
                                            yLow,
                                            yHigh,
                                            zLow,
                                            zHigh)
              #endif
              /* FIELD_EXPRESSION_THREADS */;
           }

          template<typename RhsType>
           inline void sequential_assign(RhsType rhs,
                                         int const xLow,
                                         int const xHigh,
                                         int const yLow,
                                         int const yHigh,
                                         int const zLow,
                                         int const zHigh) {
              #ifdef NEBO_REPORT_BACKEND
                 std::cout << "Starting Nebo sequential" << std::endl
              #endif
              /* NEBO_REPORT_BACKEND */;

              init().assign(rhs.init(), xLow, xHigh, yLow, yHigh, zLow, zHigh);

              #ifdef NEBO_REPORT_BACKEND
                 std::cout << "Finished Nebo sequential" << std::endl
              #endif
              /* NEBO_REPORT_BACKEND */;
           }

          inline SeqWalkType init(void) { return SeqWalkType(field_); }

          #ifdef FIELD_EXPRESSION_THREADS
             template<typename RhsType>
              inline void thread_parallel_assign(RhsType rhs,
                                                 int const xLow,
                                                 int const xHigh,
                                                 int const yLow,
                                                 int const yHigh,
                                                 int const zLow,
                                                 int const zHigh) {
                 #ifdef NEBO_REPORT_BACKEND
                    std::cout << "Starting Nebo thread parallel" << std::endl
                 #endif
                 /* NEBO_REPORT_BACKEND */;

                 Semaphore semaphore(0);

                 const int thread_count = field_.get_partition_count();

                 typename RhsType::ResizeType typedef RhsResizeType;

                 ResizeType new_lhs = resize();

                 RhsResizeType new_rhs = rhs.resize();

                 int localXLow;

                 int localXHigh;

                 int localYLow;

                 int localYHigh;

                 int localZLow;

                 int localZHigh;

                 const structured::IntVec split = nebo_find_partition(structured::
                                                                      IntVec(xHigh
                                                                             -
                                                                             xLow,
                                                                             yHigh
                                                                             -
                                                                             yLow,
                                                                             zHigh
                                                                             -
                                                                             zLow),
                                                                      thread_count);

                 const int max = nebo_partition_count(split);

                 structured::IntVec location = structured::IntVec(0, 0, 0);

                 for(int count = 0; count < max; count++) {
                    nebo_set_up_extents(location,
                                        split,
                                        localXLow,
                                        localXHigh,
                                        localYLow,
                                        localYHigh,
                                        localZLow,
                                        localZHigh,
                                        xLow,
                                        xHigh,
                                        yLow,
                                        yHigh,
                                        zLow,
                                        zHigh);

                    ThreadPoolFIFO::self().schedule(boost::bind(&ResizeType::
                                                                template assign<RhsResizeType>,
                                                                new_lhs,
                                                                new_rhs,
                                                                localXLow,
                                                                localXHigh,
                                                                localYLow,
                                                                localYHigh,
                                                                localZLow,
                                                                localZHigh,
                                                                &semaphore));

                    location = nebo_next_partition(location, split);
                 };

                 for(int ii = 0; ii < max; ii++) { semaphore.wait(); };

                 #ifdef NEBO_REPORT_BACKEND
                    std::cout << "Finished Nebo thread parallel" << std::endl
                 #endif
                 /* NEBO_REPORT_BACKEND */;
              }

             inline ResizeType resize(void) { return ResizeType(field_); }
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             template<typename RhsType>
              inline void gpu_assign(RhsType rhs,
                                     int const xLow,
                                     int const xHigh,
                                     int const yLow,
                                     int const yHigh,
                                     int const zLow,
                                     int const zHigh) {
                 #ifdef NEBO_REPORT_BACKEND
                    std::cout << "Starting Nebo CUDA" << std::endl
                 #endif
                 /* NEBO_REPORT_BACKEND */;

                 typename RhsType::GPUWalkType typedef RhsGPUWalkType;

                 int xExtent = xHigh - xLow;

                 int yExtent = yHigh - yLow;

                 int blockDim = 16;

                 int xGDim = xExtent / blockDim + ((xExtent % blockDim) > 0 ? 1
                                                   : 0);

                 int yGDim = yExtent / blockDim + ((yExtent % blockDim) > 0 ? 1
                                                   : 0);

                 dim3 dimBlock(blockDim, blockDim);

                 dim3 dimGrid(xGDim, yGDim);

                 #ifndef NDEBUG
                    cudaError err;

                    if(cudaSuccess != (err = cudaStreamSynchronize(field_.get_stream())))
                    {
                       std::ostringstream msg;
                       msg << "Nebo error in " << "CUDA Kernel - before call" <<
                       ":\n";
                       msg << "	 - " << cudaGetErrorString(err);
                       msg << "\n";
                       msg << "\t - " << __FILE__ << " : " << __LINE__;
                       throw(std::runtime_error(msg.str()));;
                    }
                 #endif
                 /* NDEBUG */;

                 gpu_assign_kernel<GPUWalkType, RhsGPUWalkType><<<dimGrid,
                                                                  dimBlock,
                                                                  0,
                                                                  field_.get_stream()>>>(gpu_init(),
                                                                                         rhs.gpu_init(gpu_device_index()),
                                                                                         xLow,
                                                                                         xHigh,
                                                                                         yLow,
                                                                                         yHigh,
                                                                                         zLow,
                                                                                         zHigh);

                 #ifndef NDEBUG
                    if(cudaSuccess != (err = cudaStreamSynchronize(field_.get_stream())))
                    {
                       std::ostringstream msg;
                       msg << "Nebo error in " << "CUDA Kernel - after call" <<
                       ":\n";
                       msg << "	 - " << cudaGetErrorString(err);
                       msg << "\n";
                       msg << "\t - " << __FILE__ << " : " << __LINE__;
                       throw(std::runtime_error(msg.str()));;
                    }
                 #endif
                 /* NDEBUG */;

                 #ifdef NEBO_REPORT_BACKEND
                    std::cout << "Finished Nebo CUDA" << std::endl
                 #endif
                 /* NEBO_REPORT_BACKEND */;
              }

             inline bool cpu_ready(void) const {
                return IS_CPU_INDEX(field_.device_index());
             }

             inline bool gpu_ready(void) const {
                return IS_GPU_INDEX(field_.device_index());
             }

             inline int gpu_device_index(void) const {
                return field_.device_index();
             }

             inline GPUWalkType gpu_init(void) { return GPUWalkType(field_); }

             #ifdef NEBO_GPU_TEST
                template<typename RhsType>
                 inline void gpu_test_assign(RhsType rhs,
                                             int const xLow,
                                             int const xHigh,
                                             int const yLow,
                                             int const yHigh,
                                             int const zLow,
                                             int const zHigh) {
                    #ifdef NEBO_REPORT_BACKEND
                       std::cout << "Starting Nebo CUDA with Nebo copying" <<
                       std::endl
                    #endif
                    /* NEBO_REPORT_BACKEND */;

                    rhs.gpu_prep(0);

                    if(CPU_INDEX == field_.device_index()) {
                       FieldType gpu_field(field_.window_with_ghost(),
                                           field_.boundary_info(),
                                           field_.get_valid_ghost_data(),
                                           NULL,
                                           structured::InternalStorage,
                                           GPU_INDEX);

                       NeboField<Initial, FieldType> gpu_lhs(gpu_field);

                       ema::cuda::CUDADeviceInterface & CDI = ema::cuda::
                       CUDADeviceInterface::self();

                       FieldType & const ftmp_ = field_;

                       CDI.memcpy_to(gpu_field.field_values(GPU_INDEX),
                                     ftmp_.field_values(),
                                     ftmp_.allocated_bytes(),
                                     0,
                                     ftmp_.get_stream());

                       gpu_lhs.template gpu_assign<RhsType>(rhs,
                                                            xLow,
                                                            xHigh,
                                                            yLow,
                                                            yHigh,
                                                            zLow,
                                                            zHigh);

                       CDI.memcpy_from(field_.field_values(),
                                       gpu_field.field_values(GPU_INDEX),
                                       field_.allocated_bytes(),
                                       0,
                                       field_.get_stream());
                    }
                    else {
                       gpu_assign<RhsType>(rhs,
                                           xLow,
                                           xHigh,
                                           yLow,
                                           yHigh,
                                           zLow,
                                           zHigh);
                    };

                    #ifdef NEBO_REPORT_BACKEND
                       std::cout << "Finished Nebo CUDA with Nebo copying" <<
                       std::endl
                    #endif
                    /* NEBO_REPORT_BACKEND */;
                 }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

          FieldType field_;
      };
      #ifdef FIELD_EXPRESSION_THREADS
         template<typename FieldType>
          struct NeboField<Resize, FieldType> {
            public:
             FieldType typedef field_type;

             NeboField<SeqWalk, FieldType> typedef SeqWalkType;

             NeboField(FieldType f)
             : field_(f)
             {}

             #ifdef FIELD_EXPRESSION_THREADS
                template<typename RhsType>
                 inline void assign(RhsType const & rhs,
                                    int const xLow,
                                    int const xHigh,
                                    int const yLow,
                                    int const yHigh,
                                    int const zLow,
                                    int const zHigh,
                                    Semaphore * semaphore) {
                    init().assign(rhs.init(),
                                  xLow,
                                  xHigh,
                                  yLow,
                                  yHigh,
                                  zLow,
                                  zHigh);

                    semaphore->post();
                 }
             #endif
             /* FIELD_EXPRESSION_THREADS */

            private:
             inline SeqWalkType init(void) { return SeqWalkType(field_); }

             FieldType field_;
         }
      #endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename FieldType>
       struct NeboField<SeqWalk, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboField(FieldType f)
          : xGlob_(f.window_with_ghost().glob_dim(0)),
            yGlob_(f.window_with_ghost().glob_dim(1)),
            base_(f.field_values(CPU_INDEX) + (f.window_with_ghost().offset(0) +
                                               f.get_valid_ghost_data().get_minus(0))
                  + (f.window_with_ghost().glob_dim(0) * ((f.window_with_ghost().offset(1)
                                                           + f.get_valid_ghost_data().get_minus(1))
                                                          + (f.window_with_ghost().glob_dim(1)
                                                             * (f.window_with_ghost().offset(2)
                                                                + f.get_valid_ghost_data().get_minus(2))))))
          {}

          template<typename RhsType>
           inline void assign(RhsType rhs,
                              int const xLow,
                              int const xHigh,
                              int const yLow,
                              int const yHigh,
                              int const zLow,
                              int const zHigh) {
              for(int z = zLow; z < zHigh; z++) {
                 for(int y = yLow; y < yHigh; y++) {
                    for(int x = xLow; x < xHigh; x++) {
                       ref(x, y, z) = rhs.eval(x, y, z);
                    };
                 };
              };
           }

         private:
          inline value_type & ref(int const x, int const y, int const z) {
             return base_[x + xGlob_ * (y + (yGlob_ * z))];
          }

          int const xGlob_;

          int const yGlob_;

          value_type * base_;
      };
      #ifdef __CUDACC__
         template<typename FieldType>
          struct NeboField<GPUWalk, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboField(FieldType f)
             : base_(f.field_values(GPU_INDEX) + (f.window_with_ghost().offset(0)
                                                  + f.get_valid_ghost_data().get_minus(0))
                     + (f.window_with_ghost().glob_dim(0) * ((f.window_with_ghost().offset(1)
                                                              + f.get_valid_ghost_data().get_minus(1))
                                                             + (f.window_with_ghost().glob_dim(1)
                                                                * (f.window_with_ghost().offset(2)
                                                                   + f.get_valid_ghost_data().get_minus(2)))))),
               valid_(false),
               xGlob_(f.window_with_ghost().glob_dim(0)),
               yGlob_(f.window_with_ghost().glob_dim(1))
             {}

             template<typename RhsType>
              __device__ inline void assign(RhsType rhs,
                                            int const xLow,
                                            int const xHigh,
                                            int const yLow,
                                            int const yHigh,
                                            int const zLow,
                                            int const zHigh) {
                 const int ii = blockIdx.x * blockDim.x + threadIdx.x;

                 const int jj = blockIdx.y * blockDim.y + threadIdx.y;

                 const int x = ii + xLow;

                 const int y = jj + yLow;

                 start(x, y, xHigh, yHigh);

                 for(int z = zLow; z < zHigh; z++) {
                    if(valid()) { ref(x, y, z) = rhs.eval(x, y, z); };
                 };
              }

            private:
             __device__ inline bool valid(void) { return valid_; }

             __device__ inline void start(int x,
                                          int y,
                                          int const xHigh,
                                          int const yHigh) {
                valid_ = (x < xHigh && y < yHigh);
             }

             __device__ inline value_type & ref(int const x,
                                                int const y,
                                                int const z) {
                return base_[x + xGlob_ * (y + (yGlob_ * z))];
             }

             value_type * base_;

             int valid_;

             int const xGlob_;

             int const yGlob_;
         }
      #endif
      /* __CUDACC__ */;
   } /* SpatialOps */

#endif
/* NEBO_LHS_H */
