/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_STENCILS_H
   #define NEBO_STENCILS_H

   namespace SpatialOps {
      template<int Length>
       struct NeboStencilCoefCollection {
         public:
          NeboStencilCoefCollection(NeboStencilCoefCollection<Length - 1> const
                                    & o,
                                    double const c)
          : others_(o), coef_(c)
          {}

          inline NeboStencilCoefCollection<Length + 1> const operator ()(double
                                                                         const c) const {
             return NeboStencilCoefCollection<Length + 1>(*this, c);
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index >= Length) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return (index == Length - 1 ? coef() : others().get_coef(index));
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline NeboStencilCoefCollection<Length - 1> const
          others(void) const { return others_; }

         private:
          NeboStencilCoefCollection<Length - 1> const others_;

          double const coef_;
      };

      template<>
       struct NeboStencilCoefCollection<1> {
         public:
          NeboStencilCoefCollection(double const c)
          : coef_(c)
          {}

          inline NeboStencilCoefCollection<2> const operator ()(double const c) const {
             return NeboStencilCoefCollection<2>(*this, c);
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index > 1) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return coef();
          }

         private:
          double const coef_;
      };

      inline NeboStencilCoefCollection<1> const build_coef_collection(double
                                                                      const c) {
         return NeboStencilCoefCollection<1>(c);
      };

      inline NeboStencilCoefCollection<2> const build_two_point_coef_collection(double
                                                                                const
                                                                                c1,
                                                                                double
                                                                                const
                                                                                c2) {
         return NeboStencilCoefCollection<1>(c1)(c2);
      };

      inline NeboStencilCoefCollection<4> const build_four_point_coef_collection(double
                                                                                 const
                                                                                 c1,
                                                                                 double
                                                                                 const
                                                                                 c2,
                                                                                 double
                                                                                 const
                                                                                 c3,
                                                                                 double
                                                                                 const
                                                                                 c4) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4);
      };

      template<typename PointType, typename CollectionType>
       struct NeboStencilPointCollection {
         public:
          PointType typedef Point;

          CollectionType typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1 + Collection::length};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline structured::GhostData possible_ghosts(structured::
                                                              GhostData const &
                                                              ghosts) {
             return min(ghosts - point_to_ghost(Point::int_vec()),
                        Collection::possible_ghosts(ghosts));
          }
      };

      template<typename PointType>
       struct NeboStencilPointCollection<PointType, NeboNil> {
         public:
          PointType typedef Point;

          NeboNil typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline structured::GhostData possible_ghosts(structured::
                                                              GhostData const &
                                                              ghosts) {
             return ghosts - point_to_ghost(Point::int_vec());
          }
      };

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          NeboStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
          typedef SeqWalkType;

          #ifdef FIELD_EXPRESSION_THREADS
             NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, typename Arg::GPUWalkType, FieldType>
             typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return Pts::possible_ghosts(arg_.possible_ghosts());
          }

          inline structured::GhostData minimum_ghosts(void) const {
             return min(arg_.possible_ghosts(), arg_.minimum_ghosts());
          }

          inline bool has_extent(void) const { return arg_.has_extent(); }

          inline int extent(int const dir) const { return arg_.extent(dir); }

          inline SeqWalkType init(void) const {
             return SeqWalkType(arg_.init(), coefs_);
          }

          #ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize(), coefs_);
             }
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(deviceIndex), coefs_);
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;

          Coefs const coefs_;
      };
      #ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             NeboStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
             typedef SeqWalkType;

             NeboStencil(Arg const & arg, Coefs const & coefs)
             : arg_(arg), coefs_(coefs)
             {}

             inline SeqWalkType init(void) const {
                return SeqWalkType(arg_.init(), coefs_);
             }

            private:
             Arg const arg_;

             Coefs const coefs_;
         }
      #endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          template<typename PointCollection>
           struct EvalExpr {
             NeboStencilCoefCollection<PointCollection::length> typedef Coefs;

             typename PointCollection::Point typedef Point;

             typename PointCollection::Collection typedef Collection;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return EvalExpr<Collection>::eval(arg, coefs.others(), x, y, z)
                       + arg.eval(x + Point::value(0),
                                  y + Point::value(1),
                                  z + Point::value(2)) * coefs.coef();
             }
          };

          template<typename Point>
           struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
             NeboStencilCoefCollection<1> typedef Coefs;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return arg.eval(x + Point::value(0),
                                y + Point::value(1),
                                z + Point::value(2)) * coefs.coef();
             }
          };

          NeboStencil(Arg const & arg, Coefs const & coefs)
          : arg_(arg), coefs_(coefs)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
          }

         private:
          Arg arg_;

          Coefs const coefs_;
      };
      #ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             template<typename PointCollection>
              struct EvalExpr {
                NeboStencilCoefCollection<PointCollection::length> typedef Coefs
                ;

                typename PointCollection::Point typedef Point;

                typename PointCollection::Collection typedef Collection;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return EvalExpr<Collection>::eval(arg,
                                                     coefs.others(),
                                                     x,
                                                     y,
                                                     z) + arg.eval(x + Point::
                                                                   value_gpu(0),
                                                                   y + Point::
                                                                   value_gpu(1),
                                                                   z + Point::
                                                                   value_gpu(2))
                          * coefs.coef();
                }
             };

             template<typename Point>
              struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
                NeboStencilCoefCollection<1> typedef Coefs;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return arg.eval(x + Point::value_gpu(0),
                                   y + Point::value_gpu(1),
                                   z + Point::value_gpu(2)) * coefs.coef();
                }
             };

             NeboStencil(Arg const & a, Coefs const & coefs)
             : arg_(a), coefs_(coefs)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
             }

            private:
             Arg arg_;

             Coefs const coefs_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboSumStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboSumStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
          typedef SeqWalkType;

          #ifdef FIELD_EXPRESSION_THREADS
             NeboSumStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             NeboSumStencil<GPUWalk, Pts, typename Arg::GPUWalkType, FieldType>
             typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboSumStencil(Arg const & a)
          : arg_(a)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return Pts::possible_ghosts(arg_.possible_ghosts());
          }

          inline structured::GhostData minimum_ghosts(void) const {
             return min(arg_.possible_ghosts(), arg_.minimum_ghosts());
          }

          inline bool has_extent(void) const { return arg_.has_extent(); }

          inline int extent(int const dir) const { return arg_.extent(dir); }

          inline SeqWalkType init(void) const {
             return SeqWalkType(arg_.init());
          }

          #ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize());
             }
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;
      };
      #ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboSumStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
             typedef SeqWalkType;

             NeboSumStencil(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(void) const {
                return SeqWalkType(arg_.init());
             }

            private:
             Arg const arg_;
         }
      #endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          template<typename PointCollection>
           struct EvalExpr {
             typename PointCollection::Point typedef Point;

             typename PointCollection::Collection typedef Collection;

             static inline value_type eval(Arg const & arg,
                                           int const x,
                                           int const y,
                                           int const z) {
                return EvalExpr<Collection>::eval(arg, x, y, z) + arg.eval(x +
                                                                           Point::
                                                                           value(0),
                                                                           y +
                                                                           Point::
                                                                           value(1),
                                                                           z +
                                                                           Point::
                                                                           value(2));
             }
          };

          template<typename Point>
           struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
             static inline value_type eval(Arg const & arg,
                                           int const x,
                                           int const y,
                                           int const z) {
                return arg.eval(x + Point::value(0),
                                y + Point::value(1),
                                z + Point::value(2));
             }
          };

          NeboSumStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return EvalExpr<Pts>::eval(arg_, x, y, z);
          }

         private:
          Arg arg_;
      };
      #ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             template<typename PointCollection>
              struct EvalExpr {
                typename PointCollection::Point typedef Point;

                typename PointCollection::Collection typedef Collection;

                __device__ static inline value_type eval(Arg const & arg,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return EvalExpr<Collection>::eval(arg, x, y, z) + arg.eval(x
                                                                              +
                                                                              Point::
                                                                              value_gpu(0),
                                                                              y
                                                                              +
                                                                              Point::
                                                                              value_gpu(1),
                                                                              z
                                                                              +
                                                                              Point::
                                                                              value_gpu(2));
                }
             };

             template<typename Point>
              struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
                __device__ static inline value_type eval(Arg const & arg,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return arg.eval(x + Point::value_gpu(0),
                                   y + Point::value_gpu(1),
                                   z + Point::value_gpu(2));
                }
             };

             NeboSumStencil(Arg const & a)
             : arg_(a)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return EvalExpr<Pts>::eval(arg_, x, y, z);
             }

            private:
             Arg arg_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename Point>
       static inline structured::GhostData point_possible_ghosts(structured::
                                                                 GhostData const
                                                                 & ghosts) {
          return ghosts - point_to_ghost(Point::int_vec());
       };

      template<typename CurrentMode,
               typename Point,
               typename Arg,
               typename FieldType>
       struct NeboMaskShift;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<Initial, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename Arg::SeqWalkType typedef ArgSeqWalkType;

          #ifdef __CUDACC__
             typename Arg::GPUWalkType typedef ArgGPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

          #ifdef FIELD_EXPRESSION_THREADS
             NeboMaskShift<Resize, Point, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             NeboMaskShift<GPUWalk, Point, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboMaskShift(Arg const & a)
          : arg_(a)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return point_possible_ghosts<Point>(arg_.possible_ghosts());
          }

          inline structured::GhostData minimum_ghosts(void) const {
             return min(arg_.possible_ghosts(), arg_.minimum_ghosts());
          }

          inline bool has_extent(void) const { return arg_.has_extent(); }

          inline int extent(int const dir) const { return arg_.extent(dir); }

          inline SeqWalkType init(void) const {
             return SeqWalkType(arg_.init());
          }

          #ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize());
             }
          #endif
          /* FIELD_EXPRESSION_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;
      };
      #ifdef FIELD_EXPRESSION_THREADS
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<Resize, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename Arg::SeqWalkType typedef ArgSeqWalkType;

             NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboMaskShift(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(void) const {
                return SeqWalkType(arg_.init());
             }

            private:
             Arg const arg_;
         }
      #endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<SeqWalk, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboMaskShift(Arg const & arg)
          : arg_(arg)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return arg_.eval(x, y, z);
          }

         private:
          Arg arg_;
      };
      #ifdef __CUDACC__
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<GPUWalk, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboMaskShift(Arg const & a)
             : arg_(a)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return arg_.eval(x, y, z);
             }

            private:
             Arg arg_;
         }
      #endif
      /* __CUDACC__ */;
   } /* SpatialOps */

#endif
/* NEBO_STENCILS_H */
