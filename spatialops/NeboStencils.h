/* This file was generated by fulmar version 0.9.0. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_STENCILS_H
#  define NEBO_STENCILS_H

   namespace SpatialOps {
      template<int Length>
       struct NeboStencilCoefCollection {
         public:
          NeboStencilCoefCollection(NeboStencilCoefCollection<Length - 1> const
                                    & o,
                                    double const c)
          : others_(o), coef_(c)
          {}

          inline NeboStencilCoefCollection<Length + 1> const operator ()(double
                                                                         const c) const {
             return NeboStencilCoefCollection<Length + 1>(*this, c);
          }

          inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index >= Length) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return (index == Length - 1 ? coef() : others().get_coef(index));
          }

          inline NeboStencilCoefCollection<Length - 1> const others(void) const {
             return others_;
          }

         private:
          NeboStencilCoefCollection<Length - 1> const others_;

          double const coef_;
      };

      template<>
       struct NeboStencilCoefCollection<1> {
         public:
          NeboStencilCoefCollection(double const c)
          : coef_(c)
          {}

          inline NeboStencilCoefCollection<2> const operator ()(double const c) const {
             return NeboStencilCoefCollection<2>(*this, c);
          }

          inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             if(index > 1) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));;
             };

             return coef();
          }

         private:
          double const coef_;
      };

      inline NeboStencilCoefCollection<1> const build_coef_collection(double
                                                                      const c) {
         return NeboStencilCoefCollection<1>(c);
      };

      inline NeboStencilCoefCollection<2> const build_two_point_coef_collection(double
                                                                                const
                                                                                c1,
                                                                                double
                                                                                const
                                                                                c2) {
         return NeboStencilCoefCollection<1>(c1)(c2);
      };

      inline NeboStencilCoefCollection<4> const build_four_point_coef_collection(double
                                                                                 const
                                                                                 c1,
                                                                                 double
                                                                                 const
                                                                                 c2,
                                                                                 double
                                                                                 const
                                                                                 c3,
                                                                                 double
                                                                                 const
                                                                                 c4) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4);
      };

      template<typename PointType, typename CollectionType>
       struct NeboStencilPointCollection {
         public:
          PointType typedef Point;

          CollectionType typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1 + Collection::length};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline structured::GhostData possible_ghosts(structured::
                                                              GhostData const &
                                                              ghosts) {
             return min(ghosts - point_to_ghost(Point::int_vec()),
                        Collection::possible_ghosts(ghosts));
          }

          template<typename PreArg, typename DestType>
           struct ConstructExpr {
             NeboScalar<SeqWalk, typename DestType::value_type> typedef Coef;

             typename PreArg::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef> typedef MultiplyType;

             typename Collection::template ConstructExpr<PreArg, DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<SeqWalk, EarlierPointsResult, MultiplyType> typedef Result;

             static inline Result const in_sq_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<length>
                                                        const & coefs) {
                return Result(EarlierPointsType::in_sq_construct(minus,
                                                                 plus,
                                                                 shift,
                                                                 arg,
                                                                 coefs.others()),
                              MultiplyType(arg.init(minus,
                                                    plus,
                                                    shift + Point::int_vec()),
                                           Coef(coefs.coef())));
             }

             static inline Result const rs_sq_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<length>
                                                        const & coefs,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(EarlierPointsType::rs_sq_construct(shift,
                                                                 arg,
                                                                 coefs.others(),
                                                                 split,
                                                                 location),
                              MultiplyType(arg.init(shift + Point::int_vec(),
                                                    split,
                                                    location),
                                           Coef(coefs.coef())));
             }
          };

#         ifdef __CUDACC__
             template<typename PreArg, typename DestType>
              struct ConstructGPUExpr {
                NeboScalar<GPUWalk, typename DestType::value_type> typedef Coef;

                typename PreArg::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef> typedef MultiplyType;

                typename Collection::template ConstructGPUExpr<PreArg, DestType>
                typedef EarlierPointsType;

                typename EarlierPointsType::Result typedef EarlierPointsResult;

                SumOp<GPUWalk, EarlierPointsResult, MultiplyType> typedef Result
                ;

                static inline Result const in_gpu_construct(structured::IntVec
                                                            const & minus,
                                                            structured::IntVec
                                                            const & plus,
                                                            structured::IntVec
                                                            const & shift,
                                                            PreArg const & arg,
                                                            NeboStencilCoefCollection<length>
                                                            const & coefs,
                                                            int const
                                                            deviceIndex) {
                   return Result(EarlierPointsType::in_gpu_construct(minus,
                                                                     plus,
                                                                     shift,
                                                                     arg,
                                                                     coefs.others(),
                                                                     deviceIndex),
                                 MultiplyType(arg.gpu_init(minus,
                                                           plus,
                                                           shift + Point::
                                                           int_vec(),
                                                           deviceIndex),
                                              Coef(coefs.coef())));
                }
             };
#         endif
          /* __CUDACC__ */

          template<typename PreArg, typename DestType>
           struct ConstructReductionExpr {
             NeboScalar<Reduction, typename DestType::value_type> typedef Coef;

             typename PreArg::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef> typedef MultiplyType;

             typename Collection::template ConstructReductionExpr<PreArg,
                                                                  DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<Reduction, EarlierPointsResult, MultiplyType> typedef Result;

             static inline Result const in_rd_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<length>
                                                        const & coefs) {
                return Result(EarlierPointsType::in_rd_construct(minus,
                                                                 plus,
                                                                 shift,
                                                                 arg,
                                                                 coefs.others()),
                              MultiplyType(arg.reduce_init(minus,
                                                           plus,
                                                           shift + Point::
                                                           int_vec()),
                                           Coef(coefs.coef())));
             }

             static inline Result const rs_rd_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<length>
                                                        const & coefs,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(EarlierPointsType::rs_rd_construct(shift,
                                                                 arg,
                                                                 coefs.others(),
                                                                 split,
                                                                 location),
                              MultiplyType(arg.reduce_init(shift + Point::
                                                           int_vec(),
                                                           split,
                                                           location),
                                           Coef(coefs.coef())));
             }
          };

          template<typename PreArg, typename DestType>
           struct SumConstructExpr {
             typename PreArg::SeqWalkType typedef Arg;

             typename Collection::template SumConstructExpr<PreArg, DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<SeqWalk, EarlierPointsResult, Arg> typedef Result;

             static inline Result const in_sq_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg) {
                return Result(EarlierPointsType::in_sq_construct(minus,
                                                                 plus,
                                                                 shift,
                                                                 arg),
                              arg.init(minus, plus, shift + Point::int_vec()));
             }

             static inline Result const rs_sq_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(EarlierPointsType::rs_sq_construct(shift,
                                                                 arg,
                                                                 split,
                                                                 location),
                              arg.init(shift + Point::int_vec(), split, location));
             }
          };

#         ifdef __CUDACC__
             template<typename PreArg, typename DestType>
              struct SumConstructGPUExpr {
                typename PreArg::GPUWalkType typedef Arg;

                typename Collection::template SumConstructGPUExpr<PreArg,
                                                                  DestType>
                typedef EarlierPointsType;

                typename EarlierPointsType::Result typedef EarlierPointsResult;

                SumOp<GPUWalk, EarlierPointsResult, Arg> typedef Result;

                static inline Result const in_gpu_construct(structured::IntVec
                                                            const & minus,
                                                            structured::IntVec
                                                            const & plus,
                                                            structured::IntVec
                                                            const & shift,
                                                            PreArg const & arg,
                                                            int const
                                                            deviceIndex) {
                   return Result(EarlierPointsType::in_gpu_construct(minus,
                                                                     plus,
                                                                     shift,
                                                                     arg,
                                                                     deviceIndex),
                                 arg.gpu_init(minus,
                                              plus,
                                              shift + Point::int_vec(),
                                              deviceIndex));
                }
             };
#         endif
          /* __CUDACC__ */

          template<typename PreArg, typename DestType>
           struct SumConstructReductionExpr {
             typename PreArg::ReductionType typedef Arg;

             typename Collection::template SumConstructReductionExpr<PreArg,
                                                                     DestType>
             typedef EarlierPointsType;

             typename EarlierPointsType::Result typedef EarlierPointsResult;

             SumOp<Reduction, EarlierPointsResult, Arg> typedef Result;

             static inline Result const in_rd_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg) {
                return Result(EarlierPointsType::in_rd_construct(minus,
                                                                 plus,
                                                                 shift,
                                                                 arg),
                              arg.reduce_init(minus,
                                              plus,
                                              shift + Point::int_vec()));
             }

             static inline Result const rs_rd_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(EarlierPointsType::rs_rd_construct(shift,
                                                                 arg,
                                                                 split,
                                                                 location),
                              arg.reduce_init(shift + Point::int_vec(),
                                              split,
                                              location));
             }
          };
      };

      template<typename PointType>
       struct NeboStencilPointCollection<PointType, NeboNil> {
         public:
          PointType typedef Point;

          NeboNil typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          enum {length = 1};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline structured::GhostData possible_ghosts(structured::
                                                              GhostData const &
                                                              ghosts) {
             return ghosts - point_to_ghost(Point::int_vec());
          }

          template<typename PreArg, typename DestType>
           struct ConstructExpr {
             NeboScalar<SeqWalk, typename DestType::value_type> typedef Coef;

             typename PreArg::SeqWalkType typedef Arg;

             ProdOp<SeqWalk, Arg, Coef> typedef Result;

             static inline Result const in_sq_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<1>
                                                        const & coefs) {
                return Result(arg.init(minus, plus, shift + Point::int_vec()),
                              Coef(coefs.coef()));
             }

             static inline Result const rs_sq_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<1>
                                                        const & coefs,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(arg.init(shift + Point::int_vec(), split, location),
                              Coef(coefs.coef()));
             }
          };

#         ifdef __CUDACC__
             template<typename PreArg, typename DestType>
              struct ConstructGPUExpr {
                NeboScalar<GPUWalk, typename DestType::value_type> typedef Coef;

                typename PreArg::GPUWalkType typedef Arg;

                ProdOp<GPUWalk, Arg, Coef> typedef Result;

                static inline Result const in_gpu_construct(structured::IntVec
                                                            const & minus,
                                                            structured::IntVec
                                                            const & plus,
                                                            structured::IntVec
                                                            const & shift,
                                                            PreArg const & arg,
                                                            NeboStencilCoefCollection<1>
                                                            const & coefs,
                                                            int const
                                                            deviceIndex) {
                   return Result(arg.gpu_init(minus,
                                              plus,
                                              shift + Point::int_vec(),
                                              deviceIndex),
                                 Coef(coefs.coef()));
                }
             };
#         endif
          /* __CUDACC__ */

          template<typename PreArg, typename DestType>
           struct ConstructReductionExpr {
             NeboScalar<Reduction, typename DestType::value_type> typedef Coef;

             typename PreArg::ReductionType typedef Arg;

             ProdOp<Reduction, Arg, Coef> typedef Result;

             static inline Result const in_rd_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<1>
                                                        const & coefs) {
                return Result(arg.reduce_init(minus,
                                              plus,
                                              shift + Point::int_vec()),
                              Coef(coefs.coef()));
             }

             static inline Result const rs_rd_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        NeboStencilCoefCollection<1>
                                                        const & coefs,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return Result(arg.reduce_init(shift + Point::int_vec(),
                                              split,
                                              location),
                              Coef(coefs.coef()));
             }
          };

          template<typename PreArg, typename DestType>
           struct SumConstructExpr {
             typename PreArg::SeqWalkType typedef Arg;

             Arg typedef Result;

             static inline Result const in_sq_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg) {
                return arg.init(minus, plus, shift + Point::int_vec());
             }

             static inline Result const rs_sq_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return arg.init(shift + Point::int_vec(), split, location);
             }
          };

#         ifdef __CUDACC__
             template<typename PreArg, typename DestType>
              struct SumConstructGPUExpr {
                typename PreArg::GPUWalkType typedef Arg;

                Arg typedef Result;

                static inline Result const in_gpu_construct(structured::IntVec
                                                            const & minus,
                                                            structured::IntVec
                                                            const & plus,
                                                            structured::IntVec
                                                            const & shift,
                                                            PreArg const & arg,
                                                            int const
                                                            deviceIndex) {
                   return arg.gpu_init(minus,
                                       plus,
                                       shift + Point::int_vec(),
                                       deviceIndex);
                }
             };
#         endif
          /* __CUDACC__ */

          template<typename PreArg, typename DestType>
           struct SumConstructReductionExpr {
             typename PreArg::ReductionType typedef Arg;

             Arg typedef Result;

             static inline Result const in_rd_construct(structured::IntVec const
                                                        & minus,
                                                        structured::IntVec const
                                                        & plus,
                                                        structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg) {
                return arg.reduce_init(minus, plus, shift + Point::int_vec());
             }

             static inline Result const rs_rd_construct(structured::IntVec const
                                                        & shift,
                                                        PreArg const & arg,
                                                        structured::IntVec const
                                                        & split,
                                                        structured::IntVec const
                                                        & location) {
                return arg.reduce_init(shift + Point::int_vec(), split, location);
             }
          };
      };

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          typename Pts::template ConstructExpr<Arg, FieldType> typedef
          ConstructExpr;

          typename ConstructExpr::Result typedef ArgSeqWalkType;

#         ifdef __CUDACC__
             typename Pts::template ConstructGPUExpr<Arg, FieldType> typedef
             ConstructGPUExpr;
             typename ConstructGPUExpr::Result typedef ArgGPUWalkType;
#         endif
          /* __CUDACC__ */

          typename Pts::template ConstructReductionExpr<Arg, FieldType> typedef
          ConstructReductionExpr;

          typename ConstructReductionExpr::Result typedef ArgReductionType;

          NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboStencil<Reduction, Pts, ArgReductionType, FieldType> typedef
          ReductionType;

          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return Pts::possible_ghosts(arg_.possible_ghosts());
          }

          inline SeqWalkType init(structured::IntVec const & minus,
                                  structured::IntVec const & plus,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(ConstructExpr::in_sq_construct(minus,
                                                               plus,
                                                               shift,
                                                               arg_,
                                                               coefs_));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::IntVec const & minus,
                                      structured::IntVec const & plus) const {
                return ResizeType(arg_.resize(minus, plus), coefs_);
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(structured::IntVec const & minus,
                                         structured::IntVec const & plus,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(ConstructGPUExpr::in_gpu_construct(minus,
                                                                      plus,
                                                                      shift,
                                                                      arg_,
                                                                      coefs_,
                                                                      deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::IntVec const & minus,
                                           structured::IntVec const & plus,
                                           structured::IntVec const & shift) const {
             return ReductionType(ConstructExpr::in_reduce_construct(minus,
                                                                     plus,
                                                                     shift,
                                                                     arg_,
                                                                     coefs_));
          }

         private:
          Arg const arg_;

          Coefs const coefs_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             typename Pts::template ConstructExpr<Arg, FieldType> typedef
             ConstructExpr;

             typename ConstructExpr::Result typedef ArgSeqWalkType;

             NeboStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboStencil(Arg const & arg, Coefs const & coefs)
             : arg_(arg), coefs_(coefs)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(ConstructExpr::rs_sq_construct(shift,
                                                                  arg_,
                                                                  coefs_,
                                                                  split,
                                                                  location));
             }

            private:
             Arg const arg_;

             Coefs const coefs_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline value_type eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
#     ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboStencil(Arg const & a)
             : arg_(a)
             {}

             __device__ inline void start(int x, int y) { arg_.start(x, y); }

             __device__ inline void next(void) { arg_.next(); }

             __device__ inline value_type eval(void) const {
                return arg_.eval();
             }

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Reduction, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline bool at_end(void) const { return arg_.at_end(); }

          inline bool has_length(void) const { return arg_.has_length(); }

          inline value_type eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboSumStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename Pts::template SumConstructExpr<Arg, FieldType> typedef
          ConstructExpr;

          typename ConstructExpr::Result typedef ArgSeqWalkType;

#         ifdef __CUDACC__
             typename Pts::template SumConstructGPUExpr<Arg, FieldType> typedef
             ConstructGPUExpr;
             typename ConstructGPUExpr::Result typedef ArgGPUWalkType;
#         endif
          /* __CUDACC__ */

          typename Pts::template SumConstructReductionExpr<Arg, FieldType>
          typedef ConstructReductionExpr;

          typename ConstructReductionExpr::Result typedef ArgReductionType;

          NeboSumStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboSumStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboSumStencil<GPUWalk, Pts, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboSumStencil<Reduction, Pts, ArgReductionType, FieldType> typedef
          ReductionType;

          NeboSumStencil(Arg const & a)
          : arg_(a)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return Pts::possible_ghosts(arg_.possible_ghosts());
          }

          inline SeqWalkType init(structured::IntVec const & minus,
                                  structured::IntVec const & plus,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(ConstructExpr::in_sq_construct(minus,
                                                               plus,
                                                               shift,
                                                               arg_));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::IntVec const & minus,
                                      structured::IntVec const & plus) const {
                return ResizeType(arg_.resize(minus, plus));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(structured::IntVec const & minus,
                                         structured::IntVec const & plus,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(ConstructGPUExpr::in_gpu_construct(minus,
                                                                      plus,
                                                                      shift,
                                                                      arg_,
                                                                      deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::IntVec const & minus,
                                           structured::IntVec const & plus,
                                           structured::IntVec const & shift) const {
             return ReductionType(ConstructExpr::in_reduce_construct(minus,
                                                                     plus,
                                                                     shift,
                                                                     arg_));
          }

         private:
          Arg const arg_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename Pts::template SumConstructExpr<Arg, FieldType> typedef
             ConstructExpr;

             typename ConstructExpr::Result typedef ArgSeqWalkType;

             NeboSumStencil<SeqWalk, Pts, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboSumStencil(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(ConstructExpr::rs_sq_construct(shift,
                                                                  arg_,
                                                                  split,
                                                                  location));
             }

            private:
             Arg const arg_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboSumStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline value_type eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
#     ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboSumStencil(Arg const & a)
             : arg_(a)
             {}

             __device__ inline void start(int x, int y) { arg_.start(x, y); }

             __device__ inline void next(void) { arg_.next(); }

             __device__ inline value_type eval(void) const {
                return arg_.eval();
             }

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<Reduction, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboSumStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline bool at_end(void) const { return arg_.at_end(); }

          inline bool has_length(void) const { return arg_.has_length(); }

          inline value_type eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };

      template<typename Point>
       static inline structured::GhostData point_possible_ghosts(structured::
                                                                 GhostData const
                                                                 & ghosts) {
          return ghosts - point_to_ghost(Point::int_vec());
       };

      template<typename CurrentMode,
               typename Point,
               typename Arg,
               typename FieldType>
       struct NeboMaskShift;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<Initial, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename Arg::SeqWalkType typedef ArgSeqWalkType;

#         ifdef __CUDACC__
             typename Arg::GPUWalkType typedef ArgGPUWalkType;
#         endif
          /* __CUDACC__ */

          typename Arg::ReductionType typedef ArgReductionType;

          NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboMaskShift<Resize, Point, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboMaskShift<GPUWalk, Point, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboMaskShift<Reduction, Point, ArgReductionType, FieldType> typedef
          ReductionType;

          NeboMaskShift(Arg const & a)
          : arg_(a)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return point_possible_ghosts<Point>(arg_.possible_ghosts());
          }

          inline SeqWalkType init(structured::IntVec const & minus,
                                  structured::IntVec const & plus,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(arg_.init(minus, plus, shift + Point::int_vec()));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::IntVec const & minus,
                                      structured::IntVec const & plus) const {
                return ResizeType(arg_.resize(minus, plus));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(structured::IntVec const & minus,
                                         structured::IntVec const & plus,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(minus,
                                                 plus,
                                                 shift + Point::int_vec(),
                                                 deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::IntVec const & minus,
                                           structured::IntVec const & plus,
                                           structured::IntVec const & shift) const {
             return ReductionType(arg_.reduce_init(minus,
                                                   plus,
                                                   shift + Point::int_vec()));
          }

         private:
          Arg const arg_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<Resize, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename Arg::SeqWalkType typedef ArgSeqWalkType;

             NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboMaskShift(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(arg_.init(shift + Point::int_vec(),
                                             split,
                                             location));
             }

            private:
             Arg const arg_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<SeqWalk, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboMaskShift(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline bool eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
#     ifdef __CUDACC__
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<GPUWalk, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboMaskShift(Arg const & a)
             : arg_(a)
             {}

             __device__ inline void start(int x, int y) { arg_.start(x, y); }

             __device__ inline void next(void) { arg_.next(); }

             __device__ inline bool eval(void) const { return arg_.eval(); }

            private:
             Arg arg_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<Reduction, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboMaskShift(Arg const & arg)
          : arg_(arg)
          {}

          inline void next(void) { arg_.next(); }

          inline bool at_end(void) const { return arg_.at_end(); }

          inline bool has_length(void) const { return arg_.has_length(); }

          inline bool eval(void) const { return arg_.eval(); }

         private:
          Arg arg_;
      };
   } /* SpatialOps */

#endif
/* NEBO_STENCILS_H */
