#lang fulmar

 ; Copyright (c) 2014 The University of Utah
 ;
 ; Permission is hereby granted, free of charge, to any person obtaining a copy
 ; of this software and associated documentation files (the "Software"), to
 ; deal in the Software without restriction, including without limitation the
 ; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ; sell copies of the Software, and to permit persons to whom the Software is
 ; furnished to do so, subject to the following conditions:
 ;
 ; The above copyright notice and this permission notice shall be included in
 ; all copies or substantial portions of the Software.
 ;
 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ; IN THE SOFTWARE.

(provide (all-defined-out))

(define (space-after . chunks)
  (concat chunks space))
(define (spaces-around . chunks)
  (concat space chunks space))
(define (add-spaces . chunks)
  (apply between space chunks))
(define (stmt . chunks)
  (concat (add-spaces chunks) ";"))
(define (add-blank-lines . chunks)
  (apply between blank-line chunks))
(define (typedef first second)
  (typedef-smt first second))
(define (stmt-typedef first second)
  (stmt (typedef-smt first second)))
(define (val-call fcn . args)
  (function-call fcn args))
(define (stmt-call fcn . args)
  (stmt (function-call fcn args)))
(define (val-member-call obj fcn . args)
  (member-function-call obj fcn args))
(define (stmt-member-call obj fcn . args)
  (stmt (member-function-call obj fcn args)))
(define def-function function-define)
(define def-void-function void-function-define)
(define def-returning-function returning-function-define)
(define dcl-function function-declare)
(define dcl-no-inline-function general-function-declare)
(define dcl-static-function static-function-declare)
(define def-template template-define)
(define dcl-struct struct-declare)
(define def-struct struct-define)
(define dcl-template-struct template-struct-declare)
(define (stmt-dcl-template-struct . chunks)
  (stmt (apply dcl-template-struct chunks)))
(define def-template-struct template-struct-define)
(define (stmt-def-template-struct . chunks)
  (stmt (apply def-template-struct chunks)))
(define type-template template-use)
(define (typename pmtr)
  (add-spaces 'typename pmtr))
(define (type-template-function . pmtrs)
  (add-spaces 'template (apply type-template pmtrs)))
(define section-public public-section)
(define section-private private-section)
(define val-construct constructor-assignment)
(define scope scope-resolution-operator)
(define (enum . enums)
  (stmt 'enum (body-list "," enums)))
(define (pp-cond-or name then else)
  (pp-conditional-ifdef name
                        (concat then)
                        (if (not else)
                            #false
                            (concat else))))
(define (pp-threads-or then else)
  (pp-cond-or 'ENABLE_THREADS then else))
(define (pp-threads-only . chunks)
  (pp-threads-or chunks #false))
(define (pp-gpu-or then else)
  (pp-cond-or '__CUDACC__ then else))
(define (pp-gpu-only . chunks)
  (pp-gpu-or chunks #false))
(define (pp-gpu-test-or then else)
  (pp-cond-or 'NEBO_GPU_TEST then else))
(define (pp-gpu-test-only . chunks)
  (pp-gpu-test-or chunks #false))
(define (report-backend-or then else)
  (pp-cond-or 'NEBO_REPORT_BACKEND then else))
(define (report-backend-only . chunks)
  (report-backend-or chunks #false))
(define (kernel-call name . args)
  (type-template name (template-list (template-list args))))
(define (device-only . chunks)
  (add-spaces '__device__ chunks))
(define (host-device . chunks)
  (add-spaces (pp-gpu-only (add-spaces '__host__ '__device__))
              chunks))
(define (global-only . chunks)
  (add-spaces '__global__ chunks))
(define (report-backend-cout type backend-name)
  (report-backend-only (add-spaces (scope 'std 'cout)
                                   '<<
                                   (surround "\"" (add-spaces type 'Nebo backend-name))
                                   '<<
                                   (scope 'std 'endl))))
(define (report-backend-start backend-name)
  (report-backend-cout 'Starting backend-name))
(define (report-backend-finish backend-name)
  (report-backend-cout 'Finished backend-name))
(define (pp-debug-only . chunks)
  (pp-conditional-ifndef 'NDEBUG
                         (concat chunks)
                         #false))
(define (paren . chunks)
  (sur-paren (position-indent (add-spaces chunks))))
(define (ter-cond if then else)
  (paren if '? then ': else))
(define (val-assign lhs . rhs)
  (add-spaces lhs '= rhs))
(define (stmt-assign lhs . rhs)
  (stmt (val-assign lhs rhs)))
(define (val-typed-assign type lhs . rhs)
  (val-assign (add-spaces type lhs) rhs))
(define (stmt-typed-assign type lhs . rhs)
  (stmt (val-typed-assign type lhs rhs)))
(define (val-typed-const-assign type lhs . rhs)
  (val-typed-assign (add-spaces 'const type) lhs rhs))
(define (val-nebo-assign lhs . rhs)
  (add-spaces lhs '<<= rhs))
(define (stmt-nebo_assign lhs . rhs)
  (stmt (add-spaces lhs '<<= rhs)))
(define (val-equal lhs . rhs)
  (add-spaces lhs '== rhs))
(define (val-not-equal lhs . rhs)
  (add-spaces lhs '!= rhs))
(define (val-less-than lhs . rhs)
  (add-spaces lhs '< rhs))
(define (val-greater-than lhs . rhs)
  (add-spaces lhs '> rhs))
(define (val-less-equal lhs . rhs)
  (add-spaces lhs '<= rhs))
(define (val-greater-equal lhs . rhs)
  (add-spaces lhs '>= rhs))
(define (val-add lhs . rhs)
  (add-spaces lhs '+ rhs))
(define (val-subtract lhs . rhs)
  (add-spaces lhs '- rhs))
(define (val-multiply lhs . rhs)
  (add-spaces lhs '* rhs))
(define (val-divide lhs . rhs)
  (add-spaces lhs '/ rhs))
(define (val-modulo lhs . rhs)
  (add-spaces lhs '% rhs))
(define (val-increment chunk)
  (literal chunk '++))
(define (val-and lhs . rhs)
  (between (spaces-around '&&) lhs rhs))
(define (val-or lhs . rhs)
  (between (spaces-around "||") lhs rhs))
(define (val-not chunk)
  (concat '! (paren chunk)))
(define (val-negate chunk)
  (concat '- (paren chunk)))
(define (const . chunks)
  (add-spaces chunks 'const))
(define (ref . chunks)
  (add-spaces chunks '&))
(define (ptr . chunks)
  (add-spaces chunks '*))
(define (function-pmtr type arg)
  (add-spaces type arg))
(define (dcl-variable type arg)
  (add-spaces type arg))
(define (stmt-dcl-variable type arg)
  (stmt (function-pmtr type arg)))
(define (take-ptr . chunks)
  (concat '& chunks))
(define (stmt-if check . then)
  (add-spaces (val-call 'if check)
              (body then)))
(define (stmt-if-else check then else)
  (between new-line
           (stmt-if check then)
           (add-spaces 'else (body else))))
(define (stmt-for init check next . smts)
  (add-spaces (val-call 'for (add-spaces (stmt init)
                                         (stmt check)
                                         next))
              (body smts)))
