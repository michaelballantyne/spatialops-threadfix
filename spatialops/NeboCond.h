/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_COND_H
   #define NEBO_COND_H

   namespace SpatialOps {
      struct NeboNil {
         #ifdef ENABLE_THREADS
            NeboNil typedef ResizeType;
         #endif
         /* ENABLE_THREADS */

         NeboNil typedef SeqWalkType;

         #ifdef __CUDACC__
            NeboNil typedef GPUWalkType;
         #endif
         /* __CUDACC__ */

         NeboNil() {}

         template<typename FieldType>
          struct Convert { NeboNil typedef Result; };

         template<typename FieldType>
          inline NeboNil convert(void) const { return NeboNil(); }
      };

      template<typename CurrentMode,
               typename Test,
               typename Expr,
               typename FieldType>
       struct NeboClause;
      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Initial, Test, Expr, FieldType> {
         public:
          FieldType typedef field_type;

          NeboClause<SeqWalk,
                     typename Test::SeqWalkType,
                     typename Expr::SeqWalkType,
                     FieldType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboClause<Resize,
                        typename Test::ResizeType,
                        typename Expr::ResizeType,
                        FieldType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboClause<GPUWalk,
                        typename Test::GPUWalkType,
                        typename Expr::GPUWalkType,
                        FieldType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(test_.ghosts_with_bc(), expr_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(test_.ghosts_without_bc(), expr_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return test_.has_extents() || expr_.has_extents();
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if(test_.has_extents() && expr_.has_extents()) {
                   assert(test_.extents() == expr_.extents());
                }
             #endif
             /* NDEBUG */;

             return (test_.has_extents() ? test_.extents() : expr_.extents());
          }

          inline IntVec has_bc(void) const {
             return test_.has_bc() || expr_.has_bc();
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(test_.init(extents, ghosts, hasBC),
                                expr_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(test_.resize(), expr_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return test_.cpu_ready() && expr_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return test_.gpu_ready(deviceIndex) && expr_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(test_.gpu_init(extents,
                                                  ghosts,
                                                  hasBC,
                                                  deviceIndex),
                                   expr_.gpu_init(extents,
                                                  ghosts,
                                                  hasBC,
                                                  deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   test_.gpu_prep(deviceIndex);

                   expr_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Test const test_;

          Expr const expr_;
      };
      #ifdef ENABLE_THREADS
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<Resize, Test, Expr, FieldType> {
            public:
             FieldType typedef field_type;

             NeboClause<SeqWalk,
                        typename Test::SeqWalkType,
                        typename Expr::SeqWalkType,
                        FieldType> typedef SeqWalkType;

             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(test_.init(extents, ghosts, hasBC),
                                   expr_.init(extents, ghosts, hasBC));
             }

            private:
             Test const test_;

             Expr const expr_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<SeqWalk, Test, Expr, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return expr_.eval(x, y, z);
          }

          inline bool check(int const x, int const y, int const z) const {
             return test_.eval(x, y, z);
          }

         private:
          Test test_;

          Expr expr_;
      };
      #ifdef __CUDACC__
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<GPUWalk, Test, Expr, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return expr_.eval(x, y, z);
             }

             __device__ inline bool check(int const x, int const y, int const z) const {
                return test_.eval(x, y, z);
             }

            private:
             Test test_;

             Expr expr_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode,
               typename ClauseType,
               typename Otherwise,
               typename FieldType>
       struct NeboCond;
      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Initial, ClauseType, Otherwise, FieldType> {
         public:
          FieldType typedef field_type;

          NeboCond<SeqWalk,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboCond<Resize,
                      typename ClauseType::ResizeType,
                      typename Otherwise::ResizeType,
                      FieldType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboCond<GPUWalk,
                      typename ClauseType::GPUWalkType,
                      typename Otherwise::GPUWalkType,
                      FieldType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(clause_.ghosts_with_bc(), otherwise_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(clause_.ghosts_without_bc(), otherwise_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return clause_.has_extents() || otherwise_.has_extents();
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if(clause_.has_extents() && otherwise_.has_extents()) {
                   assert(clause_.extents() == otherwise_.extents());
                }
             #endif
             /* NDEBUG */;

             return (clause_.has_extents() ? clause_.extents() : otherwise_.extents());
          }

          inline IntVec has_bc(void) const {
             return clause_.has_bc() || otherwise_.has_bc();
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(clause_.init(extents, ghosts, hasBC),
                                otherwise_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(clause_.resize(), otherwise_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return clause_.cpu_ready() && otherwise_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return clause_.gpu_ready(deviceIndex) && otherwise_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(clause_.gpu_init(extents,
                                                    ghosts,
                                                    hasBC,
                                                    deviceIndex),
                                   otherwise_.gpu_init(extents,
                                                       ghosts,
                                                       hasBC,
                                                       deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   clause_.gpu_prep(deviceIndex);

                   otherwise_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

          inline ClauseType const & clause(void) const { return clause_; }

          inline Otherwise const & otherwise(void) const { return otherwise_; }

         private:
          ClauseType const clause_;

          Otherwise const otherwise_;
      };
      #ifdef ENABLE_THREADS
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<Resize, ClauseType, Otherwise, FieldType> {
            public:
             FieldType typedef field_type;

             NeboCond<SeqWalk,
                      typename ClauseType::SeqWalkType,
                      typename Otherwise::SeqWalkType,
                      FieldType> typedef SeqWalkType;

             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(clause_.init(extents, ghosts, hasBC),
                                   otherwise_.init(extents, ghosts, hasBC));
             }

            private:
             ClauseType const clause_;

             Otherwise const otherwise_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<SeqWalk, ClauseType, Otherwise, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (clause_.check(x, y, z) ? clause_.eval(x, y, z) : otherwise_.eval(x,
                                                                                      y,
                                                                                      z));
          }

         private:
          ClauseType clause_;

          Otherwise otherwise_;
      };
      #ifdef __CUDACC__
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<GPUWalk, ClauseType, Otherwise, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (clause_.check(x, y, z) ? clause_.eval(x, y, z) :
                        otherwise_.eval(x, y, z));
             }

            private:
             ClauseType clause_;

             Otherwise otherwise_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode, typename Test, typename Expr, typename T>
       struct NeboSingleValueClause;
      template<typename Test, typename Expr, typename T>
       struct NeboSingleValueClause<Initial, Test, Expr, T> {
         public:
          SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
          field_type;

          NeboSingleValueClause<SeqWalk,
                                typename Test::SeqWalkType,
                                typename Expr::SeqWalkType,
                                T> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboSingleValueClause<Resize,
                                   typename Test::ResizeType,
                                   typename Expr::ResizeType,
                                   T> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboSingleValueClause<GPUWalk,
                                   typename Test::GPUWalkType,
                                   typename Expr::GPUWalkType,
                                   T> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboSingleValueClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return GhostData(GHOST_MAX);
          }

          inline GhostData ghosts_without_bc(void) const {
             return GhostData(GHOST_MAX);
          }

          inline bool has_extents(void) const { return false; }

          inline IntVec extents(void) const { return IntVec(0, 0, 0); }

          inline IntVec has_bc(void) const { return IntVec(0, 0, 0); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(test_.init(extents, ghosts, hasBC),
                                expr_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(test_.resize(), expr_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return test_.cpu_ready() && expr_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return test_.gpu_ready(deviceIndex) && expr_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(test_.gpu_init(extents,
                                                  ghosts,
                                                  hasBC,
                                                  deviceIndex),
                                   expr_.gpu_init(extents,
                                                  ghosts,
                                                  hasBC,
                                                  deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   test_.gpu_prep(deviceIndex);

                   expr_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

          template<typename FieldType>
           struct Convert {
             NeboClause<Initial, Test, Expr, FieldType> typedef Result;

             static inline Result convert(Test const & t, Expr const & e) {
                return Result(t, e);
             }
          };

          inline Test const & test(void) const { return test_; }

          inline Expr const & expr(void) const { return expr_; }

         private:
          Test const test_;

          Expr const expr_;
      };
      #ifdef ENABLE_THREADS
         template<typename Test, typename Expr, typename T>
          struct NeboSingleValueClause<Resize, Test, Expr, T> {
            public:
             SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
             field_type;

             NeboSingleValueClause<SeqWalk,
                                   typename Test::SeqWalkType,
                                   typename Expr::SeqWalkType,
                                   T> typedef SeqWalkType;

             NeboSingleValueClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(test_.init(extents, ghosts, hasBC),
                                   expr_.init(extents, ghosts, hasBC));
             }

            private:
             Test const test_;

             Expr const expr_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Test, typename Expr, typename T>
       struct NeboSingleValueClause<SeqWalk, Test, Expr, T> {
         public:
          SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
          field_type;

          typename field_type::value_type typedef value_type;

          NeboSingleValueClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return expr_.eval(x, y, z);
          }

          inline bool check(int const x, int const y, int const z) const {
             return test_.eval(x, y, z);
          }

         private:
          Test test_;

          Expr expr_;
      };
      #ifdef __CUDACC__
         template<typename Test, typename Expr, typename T>
          struct NeboSingleValueClause<GPUWalk, Test, Expr, T> {
            public:
             SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
             field_type;

             typename field_type::value_type typedef value_type;

             NeboSingleValueClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return expr_.eval(x, y, z);
             }

             __device__ inline bool check(int const x, int const y, int const z) const {
                return test_.eval(x, y, z);
             }

            private:
             Test test_;

             Expr expr_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode,
               typename ClauseType,
               typename Otherwise,
               typename T>
       struct NeboSingleValueCond;
      template<typename ClauseType, typename Otherwise, typename T>
       struct NeboSingleValueCond<Initial, ClauseType, Otherwise, T> {
         public:
          SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
          field_type;

          NeboSingleValueCond<SeqWalk,
                              typename ClauseType::SeqWalkType,
                              typename Otherwise::SeqWalkType,
                              T> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboSingleValueCond<Resize,
                                 typename ClauseType::ResizeType,
                                 typename Otherwise::ResizeType,
                                 T> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboSingleValueCond<GPUWalk,
                                 typename ClauseType::GPUWalkType,
                                 typename Otherwise::GPUWalkType,
                                 T> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboSingleValueCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return GhostData(GHOST_MAX);
          }

          inline GhostData ghosts_without_bc(void) const {
             return GhostData(GHOST_MAX);
          }

          inline bool has_extents(void) const { return false; }

          inline IntVec extents(void) const { return IntVec(0, 0, 0); }

          inline IntVec has_bc(void) const { return IntVec(0, 0, 0); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(clause_.init(extents, ghosts, hasBC),
                                otherwise_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(clause_.resize(), otherwise_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return clause_.cpu_ready() && otherwise_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return clause_.gpu_ready(deviceIndex) && otherwise_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(clause_.gpu_init(extents,
                                                    ghosts,
                                                    hasBC,
                                                    deviceIndex),
                                   otherwise_.gpu_init(extents,
                                                       ghosts,
                                                       hasBC,
                                                       deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   clause_.gpu_prep(deviceIndex);

                   otherwise_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

          template<typename FieldType>
           struct Convert {
             typename ClauseType::template Convert<FieldType> typedef
             ConvertingClause;

             typename ConvertingClause::Result typedef ConvertedClause;

             typename Otherwise::template Convert<FieldType>::Result typedef
             ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType>
             typedef Result;

             static inline Result convert(ClauseType const & c,
                                          Otherwise const & o) {
                return Result(ConvertingClause::convert(c.test(), c.expr()),
                              o.template convert<FieldType>());
             }
          };

          template<typename FieldType>
           inline typename Convert<FieldType>::Result convert(void) const {
              return Convert<FieldType>::convert(clause(), otherwise());
           }

          inline ClauseType const & clause(void) const { return clause_; }

          inline Otherwise const & otherwise(void) const { return otherwise_; }

         private:
          ClauseType const clause_;

          Otherwise const otherwise_;
      };
      #ifdef ENABLE_THREADS
         template<typename ClauseType, typename Otherwise, typename T>
          struct NeboSingleValueCond<Resize, ClauseType, Otherwise, T> {
            public:
             SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
             field_type;

             NeboSingleValueCond<SeqWalk,
                                 typename ClauseType::SeqWalkType,
                                 typename Otherwise::SeqWalkType,
                                 T> typedef SeqWalkType;

             NeboSingleValueCond(ClauseType const & clause,
                                 Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(clause_.init(extents, ghosts, hasBC),
                                   otherwise_.init(extents, ghosts, hasBC));
             }

            private:
             ClauseType const clause_;

             Otherwise const otherwise_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename ClauseType, typename Otherwise, typename T>
       struct NeboSingleValueCond<SeqWalk, ClauseType, Otherwise, T> {
         public:
          SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
          field_type;

          typename field_type::value_type typedef value_type;

          NeboSingleValueCond(ClauseType const & clause,
                              Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (clause_.check(x, y, z) ? clause_.eval(x, y, z) : otherwise_.eval(x,
                                                                                      y,
                                                                                      z));
          }

         private:
          ClauseType clause_;

          Otherwise otherwise_;
      };
      #ifdef __CUDACC__
         template<typename ClauseType, typename Otherwise, typename T>
          struct NeboSingleValueCond<GPUWalk, ClauseType, Otherwise, T> {
            public:
             SpatialOps::SpatialField<SpatialOps::SingleValue, T> typedef
             field_type;

             typename field_type::value_type typedef value_type;

             NeboSingleValueCond(ClauseType const & clause,
                                 Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (clause_.check(x, y, z) ? clause_.eval(x, y, z) :
                        otherwise_.eval(x, y, z));
             }

            private:
             ClauseType clause_;

             Otherwise otherwise_;
         }
      #endif
      /* __CUDACC__ */;

      struct NeboSimpleClause {
         public:
          NeboSimpleClause(bool const & b, double const & d)
          : b_(b), d_(d)
          {}

          inline bool check(void) const { return b_; }

          inline double eval(void) const { return d_; }

          template<typename FieldType>
           struct FullConvert {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef result;

             static inline result full_convert(bool const b,
                                               typename FieldType::value_type
                                               const d) {
                return result(Boolean(b), Scalar(d));
             }
          };

          template<typename T>
           struct SingleConvert {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, T> typedef Scalar;

             NeboSingleValueClause<Initial, Boolean, Scalar, T> typedef result;

             static inline result single_convert(bool const b, T const d) {
                return result(Boolean(b), Scalar(d));
             }
          };

         private:
          bool const b_;

          double const d_;
      };

      struct NeboSimpleFinalClause {
         public:
          NeboSimpleFinalClause(double const d)
          : d_(d)
          {}

          inline double eval(void) const { return d_; }

         private:
          double const d_;
      };

      template<typename Otherwise>
       struct NeboSimpleCond {
         public:
          NeboSimpleCond(NeboSimpleClause const & c, Otherwise const & otherwise)
          : c_(c), otherwise_(otherwise)
          {}

          inline double eval(void) const {
             return (c_.check() ? c_.eval() : otherwise_.eval());
          }

          template<typename FieldType>
           struct FullConvert {
             NeboSimpleClause::template FullConvert<FieldType> typedef
             ConvertingClause;

             typename ConvertingClause::result typedef ConvertedClause;

             typename Otherwise::template FullConvert<FieldType>::result typedef
             ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType>
             typedef result;

             static inline result full_convert(NeboSimpleClause const & c,
                                               Otherwise const & o) {
                return result(ConvertingClause::full_convert(c.check(), c.eval()),
                              o.template full_convert<FieldType>());
             }
          };

          template<typename FieldType>
           inline typename FullConvert<FieldType>::result full_convert(void) const {
              return FullConvert<FieldType>::full_convert(clause(), otherwise());
           }

          template<typename T>
           struct SingleConvert {
             NeboSimpleClause::template SingleConvert<T> typedef
             ConvertingClause;

             typename ConvertingClause::result typedef ConvertedClause;

             typename Otherwise::template SingleConvert<T>::result typedef
             ConvertedClauses;

             NeboSingleValueCond<Initial, ConvertedClause, ConvertedClauses, T>
             typedef result;

             static inline result single_convert(NeboSimpleClause const & c,
                                                 Otherwise const & o) {
                return result(ConvertingClause::single_convert(c.check(), c.eval()),
                              o.template single_convert<T>());
             }
          };

          template<typename T>
           inline typename SingleConvert<T>::result single_convert(void) const {
              return SingleConvert<T>::single_convert(clause(), otherwise());
           }

          inline NeboSimpleClause const & clause(void) const { return c_; }

          inline Otherwise const & otherwise(void) const { return otherwise_; }

         private:
          NeboSimpleClause const c_;

          Otherwise const otherwise_;
      };

      template<>
       struct NeboSimpleCond<NeboNil> {
         public:
          NeboSimpleCond(NeboSimpleClause const & c, NeboNil const & nil)
          : c_(c)
          {}

          template<typename FieldType>
           struct FullConvert {
             NeboSimpleClause::template FullConvert<FieldType> typedef
             ConvertingClause;

             typename ConvertingClause::result typedef ConvertedClause;

             NeboNil typedef ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType>
             typedef result;

             static inline result full_convert(NeboSimpleClause const & c) {
                return result(ConvertingClause::full_convert(c.check(), c.eval()),
                              NeboNil());
             }
          };

          template<typename FieldType>
           inline typename FullConvert<FieldType>::result full_convert(void) const {
              return FullConvert<FieldType>::full_convert(clause());
           }

          template<typename T>
           struct SingleConvert {
             NeboSimpleClause::template SingleConvert<T> typedef
             ConvertingClause;

             typename ConvertingClause::result typedef ConvertedClause;

             NeboNil typedef ConvertedClauses;

             NeboSingleValueCond<Initial, ConvertedClause, ConvertedClauses, T>
             typedef result;

             static inline result single_convert(NeboSimpleClause const & c) {
                return result(ConvertingClause::single_convert(c.check(), c.eval()),
                              NeboNil());
             }
          };

          template<typename T>
           inline typename SingleConvert<T>::result single_convert(void) const {
              return SingleConvert<T>::single_convert(clause());
           }

          inline NeboSimpleClause const & clause(void) const { return c_; }

          inline NeboNil otherwise(void) const { return NeboNil(); }

         private:
          NeboSimpleClause const c_;
      };

      template<typename Clauses>
       struct CondBuilder;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct CondBuilder<NeboCond<Initial, ClauseType, Otherwise, FieldType> > {
         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;

          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {
             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil,
                                          PreceedingResult const & r) {
                return r;
             }
          };

          template<typename Next, typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboCond<Initial,
                                                   Next,
                                                   Following,
                                                   FieldType>,
                                          PreceedingResult> {
             NeboCond<Initial, Next, Following, FieldType> typedef Remaining;

             NeboCond<Initial, Next, PreceedingResult, FieldType> typedef
             NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l,
                                          PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(),
                                             NewResult(l.clause(), r));
             }
          };

          Clauses const clauses_;

         public:
          CondBuilder(NeboCond<Initial, ClauseType, Otherwise, FieldType> const
                      & cs)
          : clauses_(cs)
          {}

          template<typename Final>
           struct ReverseClauses;

          template<typename Final>
           struct ReverseClauses {
             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             }
          };

          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {
              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           }

          /* full X final X double */
          inline NeboExpression<typename ReverseClauses<NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type> >::
                                Result,
                                FieldType> operator ()(double const d) {
             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             typename ReverseClauses<Scalar>::Result typedef ReversedClauses;

             NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

             return ReturnType(reverse(Scalar(d)));
          }

          /* full X final X single-field */
          inline NeboExpression<typename ReverseClauses<NeboConstSingleValueField<Initial,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>
                                >::Result,
                                FieldType> operator ()(SpatialOps::SpatialField<SpatialOps::
                                                                                SingleValue,
                                                                                typename
                                                                                FieldType::
                                                                                value_type>
                                                       const & f) {
             NeboConstSingleValueField<Initial, typename FieldType::value_type>
             typedef Field;

             typename ReverseClauses<Field>::Result typedef ReversedClauses;

             NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

             return ReturnType(reverse(Field(f)));
          }

          /* full X final X single-expr */
          template<typename Expr>
           inline NeboExpression<typename ReverseClauses<Expr>::Result,
                                 FieldType> operator ()(NeboSingleValueExpression<Expr,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>
                                                        const & e) {
              typename ReverseClauses<Expr>::Result typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(reverse(e.expr()));
           }

          /* full X final X field */
          inline NeboExpression<typename ReverseClauses<NeboConstField<Initial,
                                                                       FieldType>
                                >::Result,
                                FieldType> operator ()(FieldType const & f) {
             NeboConstField<Initial, FieldType> typedef Field;

             typename ReverseClauses<Field>::Result typedef ReversedClauses;

             NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

             return ReturnType(reverse(Field(f)));
          }

          /* full X final X expr */
          template<typename Expr>
           inline NeboExpression<typename ReverseClauses<Expr>::Result,
                                 FieldType> operator ()(NeboExpression<Expr,
                                                                       FieldType>
                                                        const & e) {
              typename ReverseClauses<Expr>::Result typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(reverse(e.expr()));
           }

          /* full X bool X double */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboScalar<Initial, bool>,
                                                 NeboScalar<Initial,
                                                            typename FieldType::
                                                            value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b,
                                                               double const d) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Scalar(d)), clauses_));
          }

          /* full X bool X single-field */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboScalar<Initial, bool>,
                                                 NeboConstSingleValueField<Initial,
                                                                           typename
                                                                           FieldType::
                                                                           value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b,
                                                               SpatialOps::
                                                               SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                               const & f) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboConstSingleValueField<Initial, typename FieldType::value_type>
             typedef Field;

             NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_));
          }

          /* full X bool X single-expr */
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(bool const b,
                                                                NeboSingleValueExpression<Expr,
                                                                                          typename
                                                                                          FieldType::
                                                                                          value_type>
                                                                const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_));
           }

          /* full X bool X field */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboScalar<Initial, bool>,
                                                 NeboConstField<Initial,
                                                                FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b,
                                                               FieldType const &
                                                               f) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboConstField<Initial, FieldType> typedef Field;

             NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_));
          }

          /* full X bool X expr */
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(bool const b,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_));
           }

          /* full X single-expr X double */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                 typename
                                                                                                 FieldType::
                                                                                                 value_type>
                                                                const & nb,
                                                                double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_));
           }

          /* full X single-expr X single-field */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                 typename
                                                                                                 FieldType::
                                                                                                 value_type>
                                                                const & nb,
                                                                SpatialOps::
                                                                SpatialField<SpatialOps::
                                                                             SingleValue,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                                const & f) {
              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          /* full X single-expr X single-expr */
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                 typename
                                                                                                 FieldType::
                                                                                                 value_type>
                                                                const & nb,
                                                                NeboSingleValueExpression<Expr,
                                                                                          typename
                                                                                          FieldType::
                                                                                          value_type>
                                                                const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          /* full X single-expr X field */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 FieldType>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                 typename
                                                                                                 FieldType::
                                                                                                 value_type>
                                                                const & nb,
                                                                FieldType const
                                                                & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          /* full X single-expr X expr */
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                 typename
                                                                                                 FieldType::
                                                                                                 value_type>
                                                                const & nb,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          /* full X expr X double */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_));
           }

          /* full X expr X single-field */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                SpatialOps::
                                                                SpatialField<SpatialOps::
                                                                             SingleValue,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                                const & f) {
              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          /* full X expr X single-expr */
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                NeboSingleValueExpression<Expr,
                                                                                          typename
                                                                                          FieldType::
                                                                                          value_type>
                                                                const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          /* full X expr X field */
          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 FieldType>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                FieldType const
                                                                & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          /* full X expr X expr */
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          /* full X mask X double */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboMask<Initial, FieldType>,
                                                 NeboScalar<Initial,
                                                            typename FieldType::
                                                            value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(SpatialMask<FieldType>
                                                               const & mask,
                                                               double const d) {
             NeboMask<Initial, FieldType> typedef Mask;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Mask(mask), Scalar(d)), clauses_));
          }

          /* full X mask X single-field */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboMask<Initial, FieldType>,
                                                 NeboConstSingleValueField<Initial,
                                                                           typename
                                                                           FieldType::
                                                                           value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(SpatialMask<FieldType>
                                                               const & mask,
                                                               SpatialOps::
                                                               SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                               const & f) {
             NeboMask<Initial, FieldType> typedef Mask;

             NeboConstSingleValueField<Initial, typename FieldType::value_type>
             typedef Field;

             NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Mask(mask), Field(f)), clauses_));
          }

          /* full X mask X single-expr */
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial, FieldType>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(SpatialMask<FieldType>
                                                                const & mask,
                                                                NeboSingleValueExpression<Expr,
                                                                                          typename
                                                                                          FieldType::
                                                                                          value_type>
                                                                const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()), clauses_));
           }

          /* full X mask X field */
          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboMask<Initial, FieldType>,
                                                 NeboConstField<Initial,
                                                                FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(SpatialMask<FieldType>
                                                               const & mask,
                                                               FieldType const &
                                                               f) {
             NeboMask<Initial, FieldType> typedef Mask;

             NeboConstField<Initial, FieldType> typedef Field;

             NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Mask(mask), Field(f)), clauses_));
          }

          /* full X mask X expr */
          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial, FieldType>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(SpatialMask<FieldType>
                                                                const & mask,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()), clauses_));
           }
      };

      template<typename ClauseType, typename Otherwise, typename T>
       struct CondBuilder<NeboSingleValueCond<Initial, ClauseType, Otherwise, T>
       > {
         public:
          NeboSingleValueCond<Initial, ClauseType, Otherwise, T>  typedef
          Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;

          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {
             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil,
                                          PreceedingResult const & r) {
                return r;
             }
          };

          template<typename Next, typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboSingleValueCond<Initial,
                                                              Next,
                                                              Following,
                                                              T>,
                                          PreceedingResult> {
             NeboSingleValueCond<Initial, Next, Following, T> typedef Remaining;

             NeboSingleValueCond<Initial, Next, PreceedingResult, T> typedef
             NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l,
                                          PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(),
                                             NewResult(l.clause(), r));
             }
          };

          Clauses const clauses_;

         public:
          CondBuilder(NeboSingleValueCond<Initial, ClauseType, Otherwise, T>
                      const & cs)
          : clauses_(cs)
          {}

          template<typename Final>
           struct ReverseClauses;

          template<typename Final>
           struct ReverseClauses {
             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             }
          };

          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {
              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           }

          /* single X final X double */
          inline NeboSingleValueExpression<typename ReverseClauses<NeboScalar<Initial,
                                                                              T>
                                           >::Result,
                                           T> operator ()(double const d) {
             NeboScalar<Initial, T> typedef Scalar;

             typename ReverseClauses<Scalar>::Result typedef ReversedClauses;

             NeboSingleValueExpression<ReversedClauses, T> typedef ReturnType;

             return ReturnType(reverse(Scalar(d)));
          }

          /* single X final X single-field */
          inline NeboSingleValueExpression<typename ReverseClauses<NeboConstSingleValueField<Initial,
                                                                                             T>
                                           >::Result,
                                           T> operator ()(SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       T> const
                                                          & f) {
             NeboConstSingleValueField<Initial, T> typedef Field;

             typename ReverseClauses<Field>::Result typedef ReversedClauses;

             NeboSingleValueExpression<ReversedClauses, T> typedef ReturnType;

             return ReturnType(reverse(Field(f)));
          }

          /* single X final X single-expr */
          template<typename Expr>
           inline NeboSingleValueExpression<typename ReverseClauses<Expr>::
                                            Result,
                                            T> operator ()(NeboSingleValueExpression<Expr,
                                                                                     T>
                                                           const & e) {
              typename ReverseClauses<Expr>::Result typedef ReversedClauses;

              NeboSingleValueExpression<ReversedClauses, T> typedef ReturnType;

              return ReturnType(reverse(e.expr()));
           }

          /* single X final X field */
          template<typename FieldType>
           inline NeboExpression<typename ReverseClauses<NeboConstField<Initial,
                                                                        typename
                                                                        NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                                        Result> >::
                                 Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              typename ReverseClauses<Field>::Result typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(reverse(Field(f)));
           }

          /* single X final X expr */
          template<typename Expr, typename FieldType>
           inline NeboExpression<typename ReverseClauses<Expr>::Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(NeboExpression<Expr, FieldType> const & e) {
              typename ReverseClauses<Expr>::Result typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(reverse(e.expr()));
           }

          /* single X bool X double */
          inline CondBuilder<NeboSingleValueCond<Initial,
                                                 NeboSingleValueClause<Initial,
                                                                       NeboScalar<Initial,
                                                                                  bool>,
                                                                       NeboScalar<Initial,
                                                                                  T>,
                                                                       T>,
                                                 Clauses,
                                                 T> > operator ()(bool const b,
                                                                  double const d) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, T> typedef Scalar;

             NeboSingleValueClause<Initial, Boolean, Scalar, T> typedef Clause;

             NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Scalar(d)), clauses_));
          }

          /* single X bool X single-field */
          inline CondBuilder<NeboSingleValueCond<Initial,
                                                 NeboSingleValueClause<Initial,
                                                                       NeboScalar<Initial,
                                                                                  bool>,
                                                                       NeboConstSingleValueField<Initial,
                                                                                                 T>,
                                                                       T>,
                                                 Clauses,
                                                 T> > operator ()(bool const b,
                                                                  SpatialOps::
                                                                  SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                                  const & f) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboConstSingleValueField<Initial, T> typedef Field;

             NeboSingleValueClause<Initial, Boolean, Field, T> typedef Clause;

             NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_));
          }

          /* single X bool X single-expr */
          template<typename Expr>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        NeboScalar<Initial,
                                                                                   bool>,
                                                                        Expr,
                                                                        T>,
                                                  Clauses,
                                                  T> > operator ()(bool const b,
                                                                   NeboSingleValueExpression<Expr,
                                                                                             T>
                                                                   const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboSingleValueClause<Initial, Boolean, Expr, T> typedef Clause;

              NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_));
           }

          /* single X bool X field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             FieldType const & f) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X bool X expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X single-expr X double */
          template<typename BoolExpr>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        NeboScalar<Initial,
                                                                                   T>,
                                                                        T>,
                                                  Clauses,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   double const
                                                                   d) {
              NeboScalar<Initial, T> typedef Scalar;

              NeboSingleValueClause<Initial, BoolExpr, Scalar, T> typedef Clause;

              NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_));
           }

          /* single X single-expr X single-field */
          template<typename BoolExpr>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        NeboConstSingleValueField<Initial,
                                                                                                  T>,
                                                                        T>,
                                                  Clauses,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   SpatialOps::
                                                                   SpatialField<SpatialOps::
                                                                                SingleValue,
                                                                                T>
                                                                   const & f) {
              NeboConstSingleValueField<Initial, T> typedef Field;

              NeboSingleValueClause<Initial, BoolExpr, Field, T> typedef Clause;

              NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          /* single X single-expr X single-expr */
          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        Expr,
                                                                        T>,
                                                  Clauses,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   NeboSingleValueExpression<Expr,
                                                                                             T>
                                                                   const & e) {
              NeboSingleValueClause<Initial, BoolExpr, Expr, T> typedef Clause;

              NeboSingleValueCond<Initial, Clause, Clauses, T> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          /* single X single-expr X field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                              typename
                                                                                              FieldType::
                                                                                              value_type>
                                                             const & nb,
                                                             FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X single-expr X expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                              typename
                                                                                              FieldType::
                                                                                              value_type>
                                                             const & nb,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X expr X double */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result::value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X expr X single-field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            NeboFieldCheck<typename
                                                                                           FieldType::
                                                                                           field_type,
                                                                                           FieldType>::
                                                                            Result::
                                                                            value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                                             const & f) {
              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X expr X single-expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             NeboSingleValueExpression<Expr,
                                                                                       typename
                                                                                       FieldType::
                                                                                       value_type>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X expr X field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X expr X expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X mask X double */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboScalar<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result::value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             double const d) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Scalar(d)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X mask X single-field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            NeboFieldCheck<typename
                                                                                           FieldType::
                                                                                           field_type,
                                                                                           FieldType>::
                                                                            Result::
                                                                            value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                                             const & f) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X mask X single-expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             NeboSingleValueExpression<Expr,
                                                                                       typename
                                                                                       FieldType::
                                                                                       value_type>
                                                             const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X mask X field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             FieldType const & f) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          /* single X mask X expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }
      };

      template<typename Otherwise>
       struct CondBuilder<NeboSimpleCond<Otherwise> > {
         public:
          NeboSimpleCond<Otherwise>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;

          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {
             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil,
                                          PreceedingResult const & r) {
                return r;
             }
          };

          template<typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboSimpleCond<Following>,
                                          PreceedingResult> {
             NeboSimpleCond<Following> typedef Remaining;

             NeboSimpleCond<PreceedingResult> typedef NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l,
                                          PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(),
                                             NewResult(l.clause(), r));
             }
          };

          Clauses const clauses_;

         public:
          CondBuilder(NeboSimpleCond<Otherwise> const & cs)
          : clauses_(cs)
          {}

          template<typename Final>
           struct ReverseClauses;

          template<typename Final>
           struct ReverseClauses {
             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             }
          };

          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {
              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           }

          /* simple X final X double */
          inline double operator ()(double const d) {
             return reverse(NeboSimpleFinalClause(d)).eval();
          }

          /* simple X final X single-field */
          template<typename T>
           inline NeboSingleValueExpression<typename CondBuilder<typename
                                                                 Clauses::
                                                                 template
                                                                 SingleConvert<T>::
                                                                 result>::
                                            template ReverseClauses<NeboConstSingleValueField<Initial,
                                                                                              T>
                                            >::Result,
                                            T> operator ()(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                                           & f) {
              NeboConstSingleValueField<Initial, T> typedef Field;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Field>::Result
              typedef ReversedClauses;

              NeboSingleValueExpression<ReversedClauses, T> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template single_convert<T>()).reverse(Field(f)));
           }

          /* simple X final X single-expr */
          template<typename Expr, typename T>
           inline NeboSingleValueExpression<typename CondBuilder<typename
                                                                 Clauses::
                                                                 template
                                                                 SingleConvert<T>::
                                                                 result>::
                                            template ReverseClauses<Expr>::
                                            Result,
                                            T> operator ()(NeboSingleValueExpression<Expr,
                                                                                     T>
                                                           const & e) {
              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Expr>::Result typedef
              ReversedClauses;

              NeboSingleValueExpression<ReversedClauses, T> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template single_convert<T>()).reverse(e.expr()));
           }

          /* simple X final X field */
          template<typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template
                                                      FullConvert<typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>::
                                                      result>::template
                                 ReverseClauses<NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >::Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Field>::Result
              typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template full_convert<FieldType>()).reverse(Field(f)));
           }

          /* simple X final X expr */
          template<typename Expr, typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template
                                                      FullConvert<typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>::
                                                      result>::template
                                 ReverseClauses<Expr>::Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(NeboExpression<Expr, FieldType> const & e) {
              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Expr>::Result typedef
              ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template full_convert<FieldType>()).reverse(e.expr()));
           }

          /* simple X bool X double */
          inline CondBuilder<NeboSimpleCond<Clauses> > operator ()(bool const b,
                                                                   double const
                                                                   d) {
             NeboSimpleCond<Clauses> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NeboSimpleClause(b, d), clauses_));
          }

          /* simple X bool X single-field */
          template<typename T>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        NeboScalar<Initial,
                                                                                   bool>,
                                                                        NeboConstSingleValueField<Initial,
                                                                                                  T>,
                                                                        T>,
                                                  typename Clauses::template
                                                  SingleConvert<T>::result,
                                                  T> > operator ()(bool const b,
                                                                   SpatialOps::
                                                                   SpatialField<SpatialOps::
                                                                                SingleValue,
                                                                                T>
                                                                   const & f) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboConstSingleValueField<Initial, T> typedef Field;

              NeboSingleValueClause<Initial, Boolean, Field, T> typedef Clause;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              NeboSingleValueCond<Initial, Clause, ConvertedClauses, T> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Field(f)),
                                     clauses_.template single_convert<T>()));
           }

          /* simple X bool X single-expr */
          template<typename Expr, typename T>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        NeboScalar<Initial,
                                                                                   bool>,
                                                                        Expr,
                                                                        T>,
                                                  typename Clauses::template
                                                  SingleConvert<T>::result,
                                                  T> > operator ()(bool const b,
                                                                   NeboSingleValueExpression<Expr,
                                                                                             T>
                                                                   const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboSingleValueClause<Initial, Boolean, Expr, T> typedef Clause;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              NeboSingleValueCond<Initial, Clause, ConvertedClauses, T> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()),
                                     clauses_.template single_convert<T>()));
           }

          /* simple X bool X field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             FieldType const & f) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X bool X expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X single-expr X double */
          template<typename BoolExpr, typename T>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        NeboScalar<Initial,
                                                                                   T>,
                                                                        T>,
                                                  typename Clauses::template
                                                  SingleConvert<T>::result,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   double const
                                                                   d) {
              NeboScalar<Initial, T> typedef Scalar;

              NeboSingleValueClause<Initial, BoolExpr, Scalar, T> typedef Clause;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              NeboSingleValueCond<Initial, Clause, ConvertedClauses, T> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)),
                                     clauses_.template single_convert<T>()));
           }

          /* simple X single-expr X single-field */
          template<typename BoolExpr, typename T>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        NeboConstSingleValueField<Initial,
                                                                                                  T>,
                                                                        T>,
                                                  typename Clauses::template
                                                  SingleConvert<T>::result,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   SpatialOps::
                                                                   SpatialField<SpatialOps::
                                                                                SingleValue,
                                                                                T>
                                                                   const & f) {
              NeboConstSingleValueField<Initial, T> typedef Field;

              NeboSingleValueClause<Initial, BoolExpr, Field, T> typedef Clause;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              NeboSingleValueCond<Initial, Clause, ConvertedClauses, T> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template single_convert<T>()));
           }

          /* simple X single-expr X single-expr */
          template<typename BoolExpr, typename Expr, typename T>
           inline CondBuilder<NeboSingleValueCond<Initial,
                                                  NeboSingleValueClause<Initial,
                                                                        BoolExpr,
                                                                        Expr,
                                                                        T>,
                                                  typename Clauses::template
                                                  SingleConvert<T>::result,
                                                  T> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                                    T>
                                                                   const & nb,
                                                                   NeboSingleValueExpression<Expr,
                                                                                             T>
                                                                   const & e) {
              NeboSingleValueClause<Initial, BoolExpr, Expr, T> typedef Clause;

              typename Clauses::template SingleConvert<T>::result typedef
              ConvertedClauses;

              NeboSingleValueCond<Initial, Clause, ConvertedClauses, T> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template single_convert<T>()));
           }

          /* simple X single-expr X field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                              typename
                                                                                              FieldType::
                                                                                              value_type>
                                                             const & nb,
                                                             FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X single-expr X expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                              typename
                                                                                              FieldType::
                                                                                              value_type>
                                                             const & nb,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X expr X double */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result::value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X expr X single-field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            NeboFieldCheck<typename
                                                                                           FieldType::
                                                                                           field_type,
                                                                                           FieldType>::
                                                                            Result::
                                                                            value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                                             const & f) {
              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X expr X single-expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             NeboSingleValueExpression<Expr,
                                                                                       typename
                                                                                       FieldType::
                                                                                       value_type>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X expr X field */
          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X expr X expr */
          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X mask X double */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboScalar<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result::value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             double const d) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Scalar(d)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X mask X single-field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboConstSingleValueField<Initial,
                                                                            typename
                                                                            NeboFieldCheck<typename
                                                                                           FieldType::
                                                                                           field_type,
                                                                                           FieldType>::
                                                                            Result::
                                                                            value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                                             const & f) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboConstSingleValueField<Initial, typename FieldType::value_type>
              typedef Field;

              NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X mask X single-expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             NeboSingleValueExpression<Expr,
                                                                                       typename
                                                                                       FieldType::
                                                                                       value_type>
                                                             const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X mask X field */
          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             FieldType const & f) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Field(f)),
                                     clauses_.template full_convert<FieldType>()));
           }

          /* simple X mask X expr */
          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template FullConvert<typename
                                                                              NeboFieldCheck<typename
                                                                                             FieldType::
                                                                                             field_type,
                                                                                             FieldType>::
                                                                              Result>::
                                       result,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(SpatialMask<FieldType>
                                                             const & mask,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              typename Clauses::template FullConvert<FieldType>::result typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()),
                                     clauses_.template full_convert<FieldType>()));
           }
      };

      template<>
       struct CondBuilder<NeboNil> {
         public:
          CondBuilder() {}
      };

      /* none X final X double */
      inline double cond(double const d) { return d; };

      /* none X final X single-field */
      template<typename T>
       inline NeboSingleValueExpression<NeboConstSingleValueField<Initial, T>, T>
       cond(SpatialOps::SpatialField<SpatialOps::SingleValue, T> const & f) {
          NeboConstSingleValueField<Initial, T> typedef Field;

          NeboSingleValueExpression<Field, T> typedef ReturnType;

          return ReturnType(Field(f));
       };

      /* none X final X single-expr */
      template<typename Expr, typename T>
       inline NeboSingleValueExpression<Expr, T> cond(NeboSingleValueExpression<Expr,
                                                                                T>
                                                      const & e) { return e; };

      /* none X final X field */
      template<typename FieldType>
       inline NeboExpression<NeboConstField<Initial,
                                            typename NeboFieldCheck<typename
                                                                    FieldType::
                                                                    field_type,
                                                                    FieldType>::
                                            Result>,
                             typename NeboFieldCheck<typename FieldType::
                                                     field_type,
                                                     FieldType>::Result> cond(FieldType
                                                                              const
                                                                              &
                                                                              f) {
          NeboConstField<Initial, FieldType> typedef Field;

          NeboExpression<Field, FieldType> typedef ReturnType;

          return ReturnType(Field(f));
       };

      /* none X final X expr */
      template<typename Expr, typename FieldType>
       inline NeboExpression<Expr,
                             typename NeboFieldCheck<typename FieldType::
                                                     field_type,
                                                     FieldType>::Result> cond(NeboExpression<Expr,
                                                                                             FieldType>
                                                                              const
                                                                              &
                                                                              e) {
          return e;
       };

      /* none X bool X double */
      inline CondBuilder<NeboSimpleCond<NeboNil> > cond(bool const b,
                                                        double const d) {
         NeboSimpleCond<NeboNil> typedef Cond;

         CondBuilder<Cond> typedef ReturnType;

         return ReturnType(Cond(NeboSimpleClause(b, d), NeboNil()));
      };

      /* none X bool X single-field */
      template<typename T>
       inline CondBuilder<NeboSingleValueCond<Initial,
                                              NeboSingleValueClause<Initial,
                                                                    NeboScalar<Initial,
                                                                               bool>,
                                                                    NeboConstSingleValueField<Initial,
                                                                                              T>,
                                                                    T>,
                                              NeboNil,
                                              T> > cond(bool const b,
                                                        SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>
                                                        const & f) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboConstSingleValueField<Initial, T> typedef Field;

          NeboSingleValueClause<Initial, Boolean, Field, T> typedef Clause;

          NeboSingleValueCond<Initial, Clause, NeboNil, T> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Field(f)), NeboNil()));
       };

      /* none X bool X single-expr */
      template<typename Expr, typename T>
       inline CondBuilder<NeboSingleValueCond<Initial,
                                              NeboSingleValueClause<Initial,
                                                                    NeboScalar<Initial,
                                                                               bool>,
                                                                    Expr,
                                                                    T>,
                                              NeboNil,
                                              T> > cond(bool const b,
                                                        NeboSingleValueExpression<Expr,
                                                                                  T>
                                                        const & e) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboSingleValueClause<Initial, Boolean, Expr, T> typedef Clause;

          NeboSingleValueCond<Initial, Clause, NeboNil, T> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), e.expr()), NeboNil()));
       };

      /* none X bool X field */
      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboScalar<Initial, bool>,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(bool const b, FieldType const & f) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Field(f)), NeboNil()));
       };

      /* none X bool X expr */
      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboScalar<Initial, bool>,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(bool const b, NeboExpression<Expr, FieldType> const & e) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), e.expr()), NeboNil()));
       };

      /* none X single-expr X double */
      template<typename BoolExpr, typename T>
       inline CondBuilder<NeboSingleValueCond<Initial,
                                              NeboSingleValueClause<Initial,
                                                                    BoolExpr,
                                                                    NeboScalar<Initial,
                                                                               T>,
                                                                    T>,
                                              NeboNil,
                                              T> > cond(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                         T>
                                                        const & nb,
                                                        double const d) {
          NeboScalar<Initial, T> typedef Scalar;

          NeboSingleValueClause<Initial, BoolExpr, Scalar, T> typedef Clause;

          NeboSingleValueCond<Initial, Clause, NeboNil, T> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      /* none X single-expr X single-field */
      template<typename BoolExpr, typename T>
       inline CondBuilder<NeboSingleValueCond<Initial,
                                              NeboSingleValueClause<Initial,
                                                                    BoolExpr,
                                                                    NeboConstSingleValueField<Initial,
                                                                                              T>,
                                                                    T>,
                                              NeboNil,
                                              T> > cond(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                         T>
                                                        const & nb,
                                                        SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>
                                                        const & f) {
          NeboConstSingleValueField<Initial, T> typedef Field;

          NeboSingleValueClause<Initial, BoolExpr, Field, T> typedef Clause;

          NeboSingleValueCond<Initial, Clause, NeboNil, T> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      /* none X single-expr X single-expr */
      template<typename BoolExpr, typename Expr, typename T>
       inline CondBuilder<NeboSingleValueCond<Initial,
                                              NeboSingleValueClause<Initial,
                                                                    BoolExpr,
                                                                    Expr,
                                                                    T>,
                                              NeboNil,
                                              T> > cond(NeboBooleanSingleValueExpression<BoolExpr,
                                                                                         T>
                                                        const & nb,
                                                        NeboSingleValueExpression<Expr,
                                                                                  T>
                                                        const & e) {
          NeboSingleValueClause<Initial, BoolExpr, Expr, T> typedef Clause;

          NeboSingleValueCond<Initial, Clause, NeboNil, T> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

      /* none X single-expr X field */
      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanSingleValueExpression<BoolExpr,
                                             typename FieldType::value_type>
            const & nb,
            FieldType const & f) {
          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      /* none X single-expr X expr */
      template<typename BoolExpr, typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanSingleValueExpression<BoolExpr,
                                             typename FieldType::value_type>
            const & nb,
            NeboExpression<Expr, FieldType> const & e) {
          NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

      /* none X expr X double */
      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboScalar<Initial,
                                                         typename NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                         Result::value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            double const d) {
          NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

          NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      /* none X expr X single-field */
      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboConstSingleValueField<Initial,
                                                                        typename
                                                                        NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                                        Result::
                                                                        value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            SpatialOps::SpatialField<SpatialOps::SingleValue,
                                     typename FieldType::value_type> const & f) {
          NeboConstSingleValueField<Initial, typename FieldType::value_type>
          typedef Field;

          NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      /* none X expr X single-expr */
      template<typename BoolExpr, typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            NeboSingleValueExpression<Expr, typename FieldType::value_type>
            const & e) {
          NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

      /* none X expr X field */
      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            FieldType const & f) {
          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      /* none X expr X expr */
      template<typename BoolExpr, typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            NeboExpression<Expr, FieldType> const & e) {
          NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

      /* none X mask X double */
      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              NeboScalar<Initial,
                                                         typename NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                         Result::value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(SpatialMask<FieldType> const & mask, double const d) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

          NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), Scalar(d)), NeboNil()));
       };

      /* none X mask X single-field */
      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              NeboConstSingleValueField<Initial,
                                                                        typename
                                                                        NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                                        Result::
                                                                        value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(SpatialMask<FieldType> const & mask,
            SpatialOps::SpatialField<SpatialOps::SingleValue,
                                     typename FieldType::value_type> const & f) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboConstSingleValueField<Initial, typename FieldType::value_type>
          typedef Field;

          NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), Field(f)), NeboNil()));
       };

      /* none X mask X single-expr */
      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(SpatialMask<FieldType> const & mask,
            NeboSingleValueExpression<Expr, typename FieldType::value_type>
            const & e) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), e.expr()), NeboNil()));
       };

      /* none X mask X field */
      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(SpatialMask<FieldType> const & mask, FieldType const & f) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), Field(f)), NeboNil()));
       };

      /* none X mask X expr */
      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(SpatialMask<FieldType> const & mask,
            NeboExpression<Expr, FieldType> const & e) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), e.expr()), NeboNil()));
       };

      #define nebo_cond cond//;
   } /* SpatialOps */

#endif
/* NEBO_COND_H */
