/* This file was generated by fulmar version 0.9.0. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_COND_H
#  define NEBO_COND_H

   namespace SpatialOps {
      struct NeboNil {
#        ifdef FIELD_EXPRESSION_THREADS
            NeboNil typedef ResizeType;
#        endif
         /* FIELD_EXPRESSION_THREADS */

         NeboNil typedef SeqWalkType;

#        ifdef __CUDACC__
            NeboNil typedef GPUWalkType;
#        endif
         /* __CUDACC__ */

         NeboNil typedef ReductionType;

         NeboNil() {}
      };

      template<typename CurrentMode,
               typename Test,
               typename Expr,
               typename FieldType>
       struct NeboClause;
      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Initial, Test, Expr, FieldType> {
         public:
          FieldType typedef field_type;

          NeboClause<SeqWalk,
                     typename Test::SeqWalkType,
                     typename Expr::SeqWalkType,
                     FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboClause<Resize,
                        typename Test::ResizeType,
                        typename Expr::ResizeType,
                        FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboClause<GPUWalk,
                        typename Test::GPUWalkType,
                        typename Expr::GPUWalkType,
                        FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboClause<Reduction,
                     typename Test::ReductionType,
                     typename Expr::ReductionType,
                     FieldType> typedef ReductionType;

          NeboClause(Test const & t, Expr const & e)
          : test_(t), expr_(e)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(test_.possible_ghosts(), expr_.possible_ghosts());
          }

          inline SeqWalkType init(structured::IntVec const & minus,
                                  structured::IntVec const & plus,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(test_.init(minus, plus, shift),
                                expr_.init(minus, plus, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::IntVec const & minus,
                                      structured::IntVec const & plus) const {
                return ResizeType(test_.resize(minus, plus),
                                  expr_.resize(minus, plus));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return test_.cpu_ready() && expr_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return test_.gpu_ready(deviceIndex) && expr_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(structured::IntVec const & minus,
                                         structured::IntVec const & plus,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(test_.gpu_init(minus,
                                                  plus,
                                                  shift,
                                                  deviceIndex),
                                   expr_.gpu_init(minus,
                                                  plus,
                                                  shift,
                                                  deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   test_.gpu_prep(deviceIndex);

                   expr_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::IntVec const & minus,
                                           structured::IntVec const & plus,
                                           structured::IntVec const & shift) const {
             return ReductionType(test_.reduce_init(minus, plus, shift),
                                  expr_.reduce_init(minus, plus, shift));
          }

         private:
          Test const test_;

          Expr const expr_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<Resize, Test, Expr, FieldType> {
            public:
             FieldType typedef field_type;

             NeboClause<SeqWalk,
                        typename Test::SeqWalkType,
                        typename Expr::SeqWalkType,
                        FieldType> typedef SeqWalkType;

             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(test_.init(shift, split, location),
                                   expr_.init(shift, split, location));
             }

            private:
             Test const test_;

             Expr const expr_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<SeqWalk, Test, Expr, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return expr_.eval(x, y, z);
          }

          inline bool check(int const x, int const y, int const z) const {
             return test_.eval(x, y, z);
          }

         private:
          Test test_;

          Expr expr_;
      };
#     ifdef __CUDACC__
         template<typename Test, typename Expr, typename FieldType>
          struct NeboClause<GPUWalk, Test, Expr, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboClause(Test const & test, Expr const & expr)
             : test_(test), expr_(expr)
             {}

             __device__ inline void start(int x, int y) {
                test_.start(x, y); expr_.start(x, y);
             }

             __device__ inline void next(void) { test_.next(); expr_.next(); }

             __device__ inline value_type eval(void) const {
                return expr_.eval();
             }

             __device__ inline bool check(void) const { return test_.eval(); }

            private:
             Test test_;

             Expr expr_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename Test, typename Expr, typename FieldType>
       struct NeboClause<Reduction, Test, Expr, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboClause(Test const & test, Expr const & expr)
          : test_(test), expr_(expr)
          {}

          inline void next(void) { test_.next(); expr_.next(); }

          inline bool at_end(void) const {
             return (test_.at_end() || expr_.at_end());
          }

          inline bool has_length(void) const {
             return (test_.has_length() || expr_.has_length());
          }

          inline value_type eval(void) const { return expr_.eval(); }

          inline bool check(void) const { return test_.eval(); }

         private:
          Test test_;

          Expr expr_;
      };

      template<typename CurrentMode,
               typename ClauseType,
               typename Otherwise,
               typename FieldType>
       struct NeboCond;
      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Initial, ClauseType, Otherwise, FieldType> {
         public:
          FieldType typedef field_type;

          NeboCond<SeqWalk,
                   typename ClauseType::SeqWalkType,
                   typename Otherwise::SeqWalkType,
                   FieldType> typedef SeqWalkType;

#         ifdef FIELD_EXPRESSION_THREADS
             NeboCond<Resize,
                      typename ClauseType::ResizeType,
                      typename Otherwise::ResizeType,
                      FieldType> typedef ResizeType;
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             NeboCond<GPUWalk,
                      typename ClauseType::GPUWalkType,
                      typename Otherwise::GPUWalkType,
                      FieldType> typedef GPUWalkType;
#         endif
          /* __CUDACC__ */

          NeboCond<Reduction,
                   typename ClauseType::ReductionType,
                   typename Otherwise::ReductionType,
                   FieldType> typedef ReductionType;

          NeboCond(ClauseType const & c, Otherwise const & e)
          : clause_(c), otherwise_(e)
          {}

          inline structured::GhostData possible_ghosts(void) const {
             return min(clause_.possible_ghosts(), otherwise_.possible_ghosts());
          }

          inline SeqWalkType init(structured::IntVec const & minus,
                                  structured::IntVec const & plus,
                                  structured::IntVec const & shift) const {
             return SeqWalkType(clause_.init(minus, plus, shift),
                                otherwise_.init(minus, plus, shift));
          }

#         ifdef FIELD_EXPRESSION_THREADS
             inline ResizeType resize(structured::IntVec const & minus,
                                      structured::IntVec const & plus) const {
                return ResizeType(clause_.resize(minus, plus),
                                  otherwise_.resize(minus, plus));
             }
#         endif
          /* FIELD_EXPRESSION_THREADS */

#         ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return clause_.cpu_ready() && otherwise_.cpu_ready();
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return clause_.gpu_ready(deviceIndex) && otherwise_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(structured::IntVec const & minus,
                                         structured::IntVec const & plus,
                                         structured::IntVec const & shift,
                                         int const deviceIndex) const {
                return GPUWalkType(clause_.gpu_init(minus,
                                                    plus,
                                                    shift,
                                                    deviceIndex),
                                   otherwise_.gpu_init(minus,
                                                       plus,
                                                       shift,
                                                       deviceIndex));
             }

#            ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   clause_.gpu_prep(deviceIndex);

                   otherwise_.gpu_prep(deviceIndex);
                }
#            endif
             /* NEBO_GPU_TEST */
#         endif
          /* __CUDACC__ */

          inline ReductionType reduce_init(structured::IntVec const & minus,
                                           structured::IntVec const & plus,
                                           structured::IntVec const & shift) const {
             return ReductionType(clause_.reduce_init(minus, plus, shift),
                                  otherwise_.reduce_init(minus, plus, shift));
          }

          inline ClauseType const & clause(void) const { return clause_; }

          inline Otherwise const & otherwise(void) const { return otherwise_; }

         private:
          ClauseType const clause_;

          Otherwise const otherwise_;
      };
#     ifdef FIELD_EXPRESSION_THREADS
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<Resize, ClauseType, Otherwise, FieldType> {
            public:
             FieldType typedef field_type;

             NeboCond<SeqWalk,
                      typename ClauseType::SeqWalkType,
                      typename Otherwise::SeqWalkType,
                      FieldType> typedef SeqWalkType;

             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             inline SeqWalkType init(structured::IntVec const & shift,
                                     structured::IntVec const & split,
                                     structured::IntVec const & location) const {
                return SeqWalkType(clause_.init(shift, split, location),
                                   otherwise_.init(shift, split, location));
             }

            private:
             ClauseType const clause_;

             Otherwise const otherwise_;
         }
#     endif
      /* FIELD_EXPRESSION_THREADS */;
      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<SeqWalk, ClauseType, Otherwise, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (clause_.check(x, y, z) ? clause_.eval(x, y, z) : otherwise_.eval(x,
                                                                                      y,
                                                                                      z));
          }

         private:
          ClauseType clause_;

          Otherwise otherwise_;
      };
#     ifdef __CUDACC__
         template<typename ClauseType, typename Otherwise, typename FieldType>
          struct NeboCond<GPUWalk, ClauseType, Otherwise, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboCond(ClauseType const & clause, Otherwise const & otherwise)
             : clause_(clause), otherwise_(otherwise)
             {}

             __device__ inline void start(int x, int y) {
                clause_.start(x, y); otherwise_.start(x, y);
             }

             __device__ inline void next(void) {
                clause_.next(); otherwise_.next();
             }

             __device__ inline value_type eval(void) const {
                return (clause_.check() ? clause_.eval() : otherwise_.eval());
             }

            private:
             ClauseType clause_;

             Otherwise otherwise_;
         }
#     endif
      /* __CUDACC__ */;
      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct NeboCond<Reduction, ClauseType, Otherwise, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboCond(ClauseType const & clause, Otherwise const & otherwise)
          : clause_(clause), otherwise_(otherwise)
          {}

          inline void next(void) { clause_.next(); otherwise_.next(); }

          inline bool at_end(void) const {
             return (clause_.at_end() || otherwise_.at_end());
          }

          inline bool has_length(void) const {
             return (clause_.has_length() || otherwise_.has_length());
          }

          inline value_type eval(void) const {
             return (clause_.check() ? clause_.eval() : otherwise_.eval());
          }

         private:
          ClauseType clause_;

          Otherwise otherwise_;
      };

      struct NeboSimpleClause {
         public:
          NeboSimpleClause(bool const & b, double const & d)
          : b_(b), d_(d)
          {}

          inline bool check(void) const { return b_; }

          inline double eval(void) const { return d_; }

          template<typename FieldType>
           struct Convert {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Converted;

             static inline Converted convert(bool const b, double const d) {
                return Converted(Boolean(b), Scalar(d));
             }
          };

         private:
          bool const b_;

          double const d_;
      };

      struct NeboSimpleFinalClause {
         public:
          NeboSimpleFinalClause(double const d)
          : d_(d)
          {}

          inline double eval(void) const { return d_; }

         private:
          double const d_;
      };

      template<typename Otherwise>
       struct NeboSimpleCond {
         public:
          NeboSimpleCond(NeboSimpleClause const & c, Otherwise const & otherwise)
          : c_(c), otherwise_(otherwise)
          {}

          inline double eval(void) const {
             return (c_.check() ? c_.eval() : otherwise_.eval());
          }

          template<typename FieldType>
           struct Convert {
             NeboSimpleClause::template Convert<FieldType> typedef
             ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             typename Otherwise::template Convert<FieldType> typedef
             ConvertingClauses;

             typename ConvertingClauses::Converted typedef ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType>
             typedef Converted;

             static inline Converted convert(NeboSimpleClause const & c,
                                             Otherwise const & o) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()),
                                 o.template convert<FieldType>());
             }
          };

          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {
              Convert<FieldType> typedef Convert;

              return Convert::convert(clause(), otherwise());
           }

          inline NeboSimpleClause const & clause(void) const { return c_; }

          inline Otherwise const & otherwise(void) const { return otherwise_; }

         private:
          NeboSimpleClause const c_;

          Otherwise const otherwise_;
      };

      template<>
       struct NeboSimpleCond<NeboNil> {
         public:
          NeboSimpleCond(NeboSimpleClause const & c, NeboNil const & nil)
          : c_(c)
          {}

          template<typename FieldType>
           struct Convert {
             NeboSimpleClause::template Convert<FieldType> typedef
             ConvertingClause;

             typename ConvertingClause::Converted typedef ConvertedClause;

             NeboNil typedef ConvertedClauses;

             NeboCond<Initial, ConvertedClause, ConvertedClauses, FieldType>
             typedef Converted;

             static inline Converted convert(NeboSimpleClause const & c) {
                return Converted(ConvertingClause::convert(c.check(), c.eval()),
                                 NeboNil());
             }
          };

          template<typename FieldType>
           inline typename Convert<FieldType>::Converted convert(void) const {
              Convert<FieldType> typedef Convert;

              return Convert::convert(clause());
           }

          inline NeboSimpleClause const & clause(void) const { return c_; }

          inline NeboNil otherwise(void) const { return NeboNil(); }

         private:
          NeboSimpleClause const c_;
      };

      template<typename Clauses>
       struct CondBuilder;

      template<typename ClauseType, typename Otherwise, typename FieldType>
       struct CondBuilder<NeboCond<Initial, ClauseType, Otherwise, FieldType> > {
         public:
          NeboCond<Initial, ClauseType, Otherwise, FieldType>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;

          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {
             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil,
                                          PreceedingResult const & r) {
                return r;
             }
          };

          template<typename Next,
                   typename Field,
                   typename Following,
                   typename PreceedingResult>
           struct ReverseClausesRecursive<NeboCond<Initial,
                                                   Next,
                                                   Following,
                                                   Field>,
                                          PreceedingResult> {
             NeboCond<Initial, Next, Following, Field> typedef Remaining;

             NeboCond<Initial, Next, PreceedingResult, Field> typedef NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l,
                                          PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(),
                                             NewResult(l.clause(), r));
             }
          };

          Clauses const clauses_;

         public:
          CondBuilder(NeboCond<Initial, ClauseType, Otherwise, FieldType> const
                      & cs)
          : clauses_(cs)
          {}

          template<typename Final>
           struct ReverseClauses;

          template<typename Final>
           struct ReverseClauses {
             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             }
          };

          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {
              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           }

          inline NeboExpression<typename ReverseClauses<NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type> >::
                                Result,
                                FieldType> operator ()(double const d) {
             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             typename ReverseClauses<Scalar>::Result typedef ReversedClauses;

             NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

             return ReturnType(reverse(Scalar(d)));
          }

          inline NeboExpression<typename ReverseClauses<NeboConstField<Initial,
                                                                       FieldType>
                                >::Result,
                                FieldType> operator ()(FieldType const & f) {
             NeboConstField<Initial, FieldType> typedef Field;

             typename ReverseClauses<Field>::Result typedef ReversedClauses;

             NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

             return ReturnType(reverse(Field(f)));
          }

          template<typename Expr>
           inline NeboExpression<typename ReverseClauses<Expr>::Result,
                                 FieldType> operator ()(NeboExpression<Expr,
                                                                       FieldType>
                                                        const & e) {
              typename ReverseClauses<Expr>::Result typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(reverse(e.expr()));
           }

          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboScalar<Initial, bool>,
                                                 NeboScalar<Initial,
                                                            typename FieldType::
                                                            value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b,
                                                               double const d) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Boolean, Scalar, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Scalar(d)), clauses_));
          }

          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboScalar<Initial, bool>,
                                                 NeboConstField<Initial,
                                                                FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(bool const b,
                                                               FieldType const &
                                                               f) {
             NeboScalar<Initial, bool> typedef Boolean;

             NeboConstField<Initial, FieldType> typedef Field;

             NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Boolean(b), Field(f)), clauses_));
          }

          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(bool const b,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()), clauses_));
           }

          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), clauses_));
           }

          template<typename BoolExpr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 FieldType>,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                FieldType const
                                                                & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)), clauses_));
           }

          template<typename BoolExpr, typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                      FieldType>
                                                                const & nb,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()), clauses_));
           }

          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboMask<Initial, FieldType>,
                                                 NeboScalar<Initial,
                                                            typename FieldType::
                                                            value_type>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(structured::
                                                               SpatialMask<FieldType>
                                                               const & mask,
                                                               double const d) {
             NeboMask<Initial, FieldType> typedef Mask;

             NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

             NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Mask(mask), Scalar(d)), clauses_));
          }

          inline CondBuilder<NeboCond<Initial,
                                      NeboClause<Initial,
                                                 NeboMask<Initial, FieldType>,
                                                 NeboConstField<Initial,
                                                                FieldType>,
                                                 FieldType>,
                                      Clauses,
                                      FieldType> > operator ()(structured::
                                                               SpatialMask<FieldType>
                                                               const & mask,
                                                               FieldType const &
                                                               f) {
             NeboMask<Initial, FieldType> typedef Mask;

             NeboConstField<Initial, FieldType> typedef Field;

             NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

             NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(Clause(Mask(mask), Field(f)), clauses_));
          }

          template<typename Expr>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial, FieldType>,
                                                  Expr,
                                                  FieldType>,
                                       Clauses,
                                       FieldType> > operator ()(structured::
                                                                SpatialMask<FieldType>
                                                                const & mask,
                                                                NeboExpression<Expr,
                                                                               FieldType>
                                                                const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              NeboCond<Initial, Clause, Clauses, FieldType> typedef Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()), clauses_));
           }
      };

      template<typename Otherwise>
       struct CondBuilder<NeboSimpleCond<Otherwise> > {
         public:
          NeboSimpleCond<Otherwise>  typedef Clauses;

         private:
          template<typename Remaining, typename PreceedingResult>
           struct ReverseClausesRecursive;

          template<typename PreceedingResult>
           struct ReverseClausesRecursive<NeboNil, PreceedingResult> {
             PreceedingResult typedef Result;

             static inline Result reverse(NeboNil const & nil,
                                          PreceedingResult const & r) {
                return r;
             }
          };

          template<typename Following, typename PreceedingResult>
           struct ReverseClausesRecursive<NeboSimpleCond<Following>,
                                          PreceedingResult> {
             NeboSimpleCond<Following> typedef Remaining;

             NeboSimpleCond<PreceedingResult> typedef NewResult;

             ReverseClausesRecursive<Following, NewResult> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Remaining const & l,
                                          PreceedingResult const & r) {
                return InternalCall::reverse(l.otherwise(),
                                             NewResult(l.clause(), r));
             }
          };

          Clauses const clauses_;

         public:
          CondBuilder(NeboSimpleCond<Otherwise> const & cs)
          : clauses_(cs)
          {}

          template<typename Final>
           struct ReverseClauses;

          template<typename Final>
           struct ReverseClauses {
             ReverseClausesRecursive<Clauses, Final> typedef InternalCall;

             typename InternalCall::Result typedef Result;

             static inline Result reverse(Clauses const & cs, Final const & f) {
                return InternalCall::reverse(cs, f);
             }
          };

          template<typename Final>
           inline typename ReverseClauses<Final>::Result reverse(Final const & f) {
              ReverseClauses<Final> typedef InternalCall;

              return InternalCall::reverse(clauses_, f);
           }

          inline double operator ()(double const d) {
             return reverse(NeboSimpleFinalClause(d)).eval();
          }

          template<typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template
                                                      Convert<typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>::Converted>::
                                 template ReverseClauses<NeboConstField<Initial,
                                                                        typename
                                                                        NeboFieldCheck<typename
                                                                                       FieldType::
                                                                                       field_type,
                                                                                       FieldType>::
                                                                        Result> >::
                                 Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Field>::Result
              typedef ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template convert<FieldType>()).reverse(Field(f)));
           }

          template<typename Expr, typename FieldType>
           inline NeboExpression<typename CondBuilder<typename Clauses::template
                                                      Convert<typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>::Converted>::
                                 template ReverseClauses<Expr>::Result,
                                 typename NeboFieldCheck<typename FieldType::
                                                         field_type,
                                                         FieldType>::Result>
           operator ()(NeboExpression<Expr, FieldType> const & e) {
              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              CondBuilder<ConvertedClauses> typedef NewBuilder;

              typename NewBuilder::template ReverseClauses<Expr>::Result typedef
              ReversedClauses;

              NeboExpression<ReversedClauses, FieldType> typedef ReturnType;

              return ReturnType(NewBuilder(clauses_.template convert<FieldType>()).reverse(e.expr()));
           }

          inline CondBuilder<NeboSimpleCond<Clauses> > operator ()(bool const b,
                                                                   double const
                                                                   d) {
             NeboSimpleCond<Clauses> typedef Cond;

             CondBuilder<Cond> typedef ReturnType;

             return ReturnType(Cond(NeboSimpleClause(b, d), clauses_));
          }

          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             FieldType const & f) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboScalar<Initial, bool>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(bool const b,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboScalar<Initial, bool> typedef Boolean;

              NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Boolean(b), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboScalar<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             double const d) {
              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Scalar(d)),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename BoolExpr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             FieldType const & f) {
              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename BoolExpr, typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  BoolExpr,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(NeboBooleanExpression<BoolExpr,
                                                                                   FieldType>
                                                             const & nb,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(nb.expr(), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboScalar<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(structured::
                                                             SpatialMask<FieldType>
                                                             const & mask,
                                                             double const d) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

              NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Scalar(d)),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  NeboConstField<Initial,
                                                                 typename
                                                                 NeboFieldCheck<typename
                                                                                FieldType::
                                                                                field_type,
                                                                                FieldType>::
                                                                 Result>,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(structured::
                                                             SpatialMask<FieldType>
                                                             const & mask,
                                                             FieldType const & f) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboConstField<Initial, FieldType> typedef Field;

              NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), Field(f)),
                                     clauses_.template convert<FieldType>()));
           }

          template<typename Expr, typename FieldType>
           inline CondBuilder<NeboCond<Initial,
                                       NeboClause<Initial,
                                                  NeboMask<Initial,
                                                           typename
                                                           NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                           Result>,
                                                  Expr,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                       typename Clauses::template Convert<typename
                                                                          NeboFieldCheck<typename
                                                                                         FieldType::
                                                                                         field_type,
                                                                                         FieldType>::
                                                                          Result>::
                                       Converted,
                                       typename NeboFieldCheck<typename
                                                               FieldType::
                                                               field_type,
                                                               FieldType>::
                                       Result> > operator ()(structured::
                                                             SpatialMask<FieldType>
                                                             const & mask,
                                                             NeboExpression<Expr,
                                                                            FieldType>
                                                             const & e) {
              NeboMask<Initial, FieldType> typedef Mask;

              NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

              typename Clauses::template Convert<FieldType>::Converted typedef
              ConvertedClauses;

              NeboCond<Initial, Clause, ConvertedClauses, FieldType> typedef
              Cond;

              CondBuilder<Cond> typedef ReturnType;

              return ReturnType(Cond(Clause(Mask(mask), e.expr()),
                                     clauses_.template convert<FieldType>()));
           }
      };

      template<>
       struct CondBuilder<NeboNil> {
         public:
          CondBuilder() {}
      };

      inline double cond(double const d) { return d; };

      template<typename FieldType>
       inline NeboExpression<NeboConstField<Initial,
                                            typename NeboFieldCheck<typename
                                                                    FieldType::
                                                                    field_type,
                                                                    FieldType>::
                                            Result>,
                             typename NeboFieldCheck<typename FieldType::
                                                     field_type,
                                                     FieldType>::Result> cond(FieldType
                                                                              const
                                                                              &
                                                                              f) {
          NeboConstField<Initial, FieldType> typedef Field;

          NeboExpression<Field, FieldType> typedef ReturnType;

          return ReturnType(Field(f));
       };

      template<typename Expr, typename FieldType>
       inline NeboExpression<Expr,
                             typename NeboFieldCheck<typename FieldType::
                                                     field_type,
                                                     FieldType>::Result> cond(NeboExpression<Expr,
                                                                                             FieldType>
                                                                              const
                                                                              &
                                                                              e) {
          return e;
       };

      inline CondBuilder<NeboSimpleCond<NeboNil> > cond(bool const b,
                                                        double const d) {
         NeboSimpleCond<NeboNil> typedef Cond;

         CondBuilder<Cond> typedef ReturnType;

         return ReturnType(Cond(NeboSimpleClause(b, d), NeboNil()));
      };

      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboScalar<Initial, bool>,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(bool const b, FieldType const & f) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, Boolean, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), Field(f)), NeboNil()));
       };

      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboScalar<Initial, bool>,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(bool const b, NeboExpression<Expr, FieldType> const & e) {
          NeboScalar<Initial, bool> typedef Boolean;

          NeboClause<Initial, Boolean, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Boolean(b), e.expr()), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboScalar<Initial,
                                                         typename FieldType::
                                                         value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            double const d) {
          NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

          NeboClause<Initial, BoolExpr, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Scalar(d)), NeboNil()));
       };

      template<typename BoolExpr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            FieldType const & f) {
          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, BoolExpr, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), Field(f)), NeboNil()));
       };

      template<typename BoolExpr, typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              BoolExpr,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(NeboBooleanExpression<BoolExpr, FieldType> const & nb,
            NeboExpression<Expr, FieldType> const & e) {
          NeboClause<Initial, BoolExpr, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(nb.expr(), e.expr()), NeboNil()));
       };

      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              NeboScalar<Initial,
                                                         typename FieldType::
                                                         value_type>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(structured::SpatialMask<FieldType> const & mask, double const d) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboScalar<Initial, typename FieldType::value_type> typedef Scalar;

          NeboClause<Initial, Mask, Scalar, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), Scalar(d)), NeboNil()));
       };

      template<typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              NeboConstField<Initial,
                                                             typename
                                                             NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                             Result>,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(structured::SpatialMask<FieldType> const & mask, FieldType const & f) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboConstField<Initial, FieldType> typedef Field;

          NeboClause<Initial, Mask, Field, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), Field(f)), NeboNil()));
       };

      template<typename Expr, typename FieldType>
       inline CondBuilder<NeboCond<Initial,
                                   NeboClause<Initial,
                                              NeboMask<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result>,
                                              Expr,
                                              typename NeboFieldCheck<typename
                                                                      FieldType::
                                                                      field_type,
                                                                      FieldType>::
                                              Result>,
                                   NeboNil,
                                   typename NeboFieldCheck<typename FieldType::
                                                           field_type,
                                                           FieldType>::Result> >
       cond(structured::SpatialMask<FieldType> const & mask,
            NeboExpression<Expr, FieldType> const & e) {
          NeboMask<Initial, FieldType> typedef Mask;

          NeboClause<Initial, Mask, Expr, FieldType> typedef Clause;

          NeboCond<Initial, Clause, NeboNil, FieldType> typedef Cond;

          CondBuilder<Cond> typedef ReturnType;

          return ReturnType(Cond(Clause(Mask(mask), e.expr()), NeboNil()));
       };

#     define nebo_cond cond//;
   } /* SpatialOps */

#endif
/* NEBO_COND_H */
